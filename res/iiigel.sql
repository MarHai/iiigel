-- --------------------------------------------------------
-- Host:                         127.0.0.1
-- Server Version:               5.6.26 - MySQL Community Server (GPL)
-- Server Betriebssystem:        Win32
-- HeidiSQL Version:             9.3.0.4984
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

-- Exportiere Datenbank Struktur für iiigel
CREATE DATABASE IF NOT EXISTS `iiigel` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `iiigel`;


-- Exportiere Struktur von Tabelle iiigel.chapter
CREATE TABLE IF NOT EXISTS `chapter` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdModule` int(11) unsigned NOT NULL,
  `nOrder` int(5) unsigned NOT NULL,
  `sName` varchar(255) NOT NULL,
  `sText` text NOT NULL,
  `bInterpreter` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `bLiveInterpretation` tinyint(2) unsigned NOT NULL DEFAULT '1',
  `sInterpreter` varchar(50) NOT NULL,
  `bCloud` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `bObligatoryHandin` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `bLive` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `sNote` varchar(800) NOT NULL,
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId` (`sHashId`)
) ENGINE=InnoDB AUTO_INCREMENT=73 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.chapter: ~36 rows (ungefähr)
/*!40000 ALTER TABLE `chapter` DISABLE KEYS */;
INSERT INTO `chapter` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nIdCreator`, `nIdUpdater`, `nUpdate`, `nIdModule`, `nOrder`, `sName`, `sText`, `bInterpreter`, `bLiveInterpretation`, `sInterpreter`, `bCloud`, `bObligatoryHandin`, `bLive`, `sNote`) VALUES
	(32, 'cYTNhM2RjN2Q0MTI:', 0, 1445967771, 5, 5, 1446472189, 7, 1, 'Einführung&Interface', '[headline]Kapitel 1 - Einführung&Interface[/headline]\n\n[big]SmallBasic[/big] ist eine [big]Programmiersprache[/big] für Anfänger. [big]SmallBasic[/big] ist eigentlich ziemlich leicht zu erlernen. Dazu brauch man nur ein bisschen Verstand.\nAls erstes Erkläre ich euch mit was wir uns beschäftigen werden. Ihr werdet innerhalb des nächsten Jahres Grundkenntnisse vom Programmieren erlernen. Zwischendurch werdet ihr Aufgaben erhalten. Diese können manchmal für euch noch ziemlich schwierig sein aber gebt nicht auf!\n Aufgaben stehen in grüner Schrift. In den gelben Kästen findet ihr Beispielcode. Um zu sehen was dieser macht, solltet ihr diesen am besten ausprobieren. Fettgedruckte Begriffe sind Fachwörter\n oder für euch vielleicht neue Wörter, merkt euch einfach was sie bedeuten, da ihr sie später noch öfters vorfinden werdet.\n So kommen wir zur Benutzeroberfläche, auch [big]Interface[/big] genannt, von [big]SmallBasic[/big].\n \nHier zur Erklärung:\nDie [big]1[/big] ist das Texteingabefeld wo wir später dann unseren [big]Code[/big] reinschreiben werden. In diesem Feld werden wir\n unsere späteren Programme erstellen. Wenn man eine Datei vorher gespeichert hat kann man sie auch wieder dort drin Laden.\n Es ist auch möglich mehr als eine Datei offen zu haben.\n \nNun kommen wir zur [big]2[/big]. Hier seht ihr die [big]Tool-Leiste[/big]. Über die Tool-Leiste kann man\nProgramme speicher bzw. laden wenn man schonmal eins gespeichert hatte. Narürlich kann man seine\nselbstgeschriebenen Programme über die Tool-Leiste [big]Ausführen (F5)[/big]\n\nDie [big]3[/big] ist eine Fläche in der sich andere Textfelder öffnen werden, wenn man noch welche zusätzlich öffnet.\n\n[tasks]\n\n[task]Öffnet nun SmallBasic und schaut euch alles selbst an.[/task]\n\n[/tasks]\n\nWenn ihr SmallBasic noch nicht installiert habt, lest euch das nächte Kapitel durch. Ansonsten könnt ihr mit Kapitel 2 weitermachen :) \n \nUm ins nächste Level aufzusteigen gebe folgenden Level-Code ein  document.write(NxtLvCode); \n', 0, 0, '', 0, 0, 1, ''),
	(33, 'cMjIxNmRmOTE5OTg:', 0, 1445967811, 5, 5, 1446472212, 7, 2, 'Installation', '[headline]Kapitel 2 - Installation[/headline]\nInstallation von SmallBasic zu Hause\nGeht in das Verzeichnis "P:\\ToInstall\\SmallBasic" dort werdet ihr 2 Dateien sehen. Das eine ist SmallBasic und das andere NetFramework 3.5 SP1. Zieht euch diese Dateien auf einen USB Stick.\nWenn ihr dann Zuhause seid installiert zu erst SmallBasic und wenn ein Fehler auftritt ggf. NetFramework 3.5 SP1 Installieren. Bei der Installation von SmallBasic solltet ihr darauf achten das ihr auch die Deutsche Version installiert.\n[big]Schritt 1 :[/big] Starten des Installers!\nDrückt auf Next um die Installation zu beginnen.\n\n[big]Schritt 2 :[/big] Akzeptieren der Lizenz Bestimmungen. dazu einfach unten in der Box einen hacken reinmachen und auf Next klicken. \n\n[big]Schritt 3 :[/big] Um die Deutsche Version von SmallBasic zu Installieren klickt ihr auf Main Files in der Box.\n\nNun sollte in der Box mehrere Sprachen Angezeigt werden.\n\nScrollt nun in der Box runter bis ihr auf Deutsch ("German") trefft. \n\nKlickt nun auf das Symbol vor dem Text und wählt dort "Will be installed on local hard drive" aus.\n\n[big]Schritt 4 :[/big] Nachdem ihr die Sprache ausgewählt habt sollte es wie folgt aussehen. Klickt auf Next um die Installation fortzusetzen.\n\n[big]Schritt 5 :[/big] Klickt nun auf Install\n\nNun sollte sich SmallBasic bei euch Installieren.\n\n[big]Schritt 6 :[/big] Beenden der Installation. Klickt dazu einfach auf Finish!\n\nSollten bei der Installation Probleme auftreten bitte sagt uns beschied. Wir werden versuchen euch zu helfen das Problem zu beheben!\nUm ins nächste Level aufzusteigen gebe folgenden Level-Code ein  document.write(NxtLvCode); \n', 0, 0, '', 0, 0, 1, ''),
	(34, 'cNzdiMDhkZDI2MDE:', 0, 1445967829, 5, 5, 1446472257, 7, 3, 'Unser 1. Programm', '[headline]Kapitel 3 - Unser 1. Programm[/headline]\nEs ist üblich als erstes Programm überhaupt, ein "Hello World" Programm zu schreiben. In der Informatik kennt das jeder.\nDazu gebt ihr einfach folgendes als erstes in das Textfeld ein. \n[code]\nTextWindow.WriteLine("Hello World")\n[/code]\nEs sollte dann wie folgt aussehen.\n\nIhr werdet sicher schon bemerkt haben während ihr diese Zeile eingegeben habt wurde euch durch das [big]Interface[/big] schon Hilfe angeboten, welche Befehle man benutzen kann und was sie machen.\nNun drückt ihr Ausführen oben in der Tool-leiste.\nWenn ihr alles richtig gemacht habt, sollte es so aussehen.\n\nIhr habt es geschafft euer erstes Programm ist gemacht!\n', 0, 0, '', 0, 0, 1, ''),
	(35, 'cMWUwOGYyNDQ5YjQ:', 0, 1445967846, 5, 5, 1446472302, 7, 4, 'Erklärung unseres 1.Programmes', '[headline]Kapitel 4 - Erklärung unseres 1.Programmes[/headline]\nMan kann sich das so vorstellen, ihr habt ein Blatt Papier und führt einfach nur einen Befehl aus. schreibe Hello World\nDas muss man halt dem Computer in einer für ihn verständlichen Sprache erklären. Dabei hilft uns SmallBasic und unser [big]Interface[/big].\nMan Kann den Befehl:\n[code]\nTextWindow.WriteLine("Hello World")\n[/code]\nin mehrere Teile unterteilen.\n\n[li]TextWindow[/li]\n[li]WriteLine[/li]\n[li]"Hello World"[/li]\n\n[big]TextWindow[/big] steht hierbei für ein einfaches Text Fenster das wird somit angesprochen. [big]WriteLine[/big] ist ein Schreibe\n dies und das je nach dem was man dem Programm sagt. Hierbei ist das, was ihr in den Klammern steht, hier "Hello World", dass was ihr aufschreiben wollt.\n', 0, 0, '', 0, 0, 1, ''),
	(36, 'cYWVmOWM3OGM1YWM:', 0, 1445967927, 5, 5, 1446472330, 7, 5, 'Unser 2. Programm', '[headline]Kapitel 5 - Unser 2. Programm[/headline]\nNachdem wir unser erstes Programm in SmallBasic geschrieben haben, werden wir diese nun optisch verschönern. Wir wir haben z.B. die Möglichkeit wie bei einem Textverarbeitungsprogramm die Textfarbe zu ändern. Dies geht ganz einfach, indem wir in die erste Zeile folgendes schreiben:\n[code]\nTextWindow.ForegroundColor ="yellow"\n[/code]\n\n\nAllein durch diese Zeile erscheint die Schrift nicht mehr in Weiß sondern in gelb. Nun zu der Bedeutung des neu gelernten Befehls.\nDurch TextWindow wird wieder das Textfenster angesprochen. Anders als beim der Befehl WriteLine, setzt man hier keine Klammern, da der Befehl eine [big]Eigenschaft[/big](die Textfarbe) des Textfensters ändert.  \nDer Befehl TextWindow.WriteLine ändert keine [big]Eigenschaft[/big] sondern ist eine [big]Methode[/big]. Ob ein Befehl eine [big]Methoden[/big] ist, erkennt ihr  außerdem daran, \ndass Klammern im Befehl enthalten sind und ihr im SmallBasic Interface ein Zahnrad seht. Bei [big]Eigenschaften[/big] könnt ihr ein Farbpalettensymbol erkennen, außerdem gibt es keine Klammern sondern ein Gleichzeichen. \n\nBsp. zu [big]Eigenschaften[/big] und [big]Methoden[/big] anhand eines Stiftes:\nEine [big]Methode[/big] eines Stiftes wäre zum Beispiel Stift.schreibe(“Hallo!“). Dann würde der Stift das Wort „Hallo!“ schreiben.\nWenn man aber nun die Farbe (eine [big]Eigenschaft[/big] des Stiftes) ändern will, müsste man Stift.Farbe=“gelb“ schreiben. So würde er alles was er danach schreibt in gelb schreiben.\n\n\n[li]Black[/li]\n[li]Blue[/li]\n[li]Cyan[/li]\n[li]Gray[/li]\n[li]Green[/li]\n[li]Magenta[/li]\n[li]Red[/li]\n[li]White[/li]\n[li]Yellow[/li]\n[li]DarkBlue[/li]\n[li]DarkCyan[/li]\n[li]DarkGray[/li]\n[li]DarkGreen[/li]\n[li]DarkMagenta[/li]\n[li]DarkRed[/li]\n[li]DarkWhite[/li]\n[li]DarkYellow[/li]\n\n\n[tasks]\nAufgabe1&2: [break]\n \n  [task]Probiert mit den versch. Farben rum. Probiert auch, was der Befehl " TextWindow.BackroundColor="red" " macht.[/task]\n    [task]Schreibt nun ein Programm, dass nachher das ausgibt:[/task]\n \n[/tasks]\n\n\n', 0, 0, '', 0, 0, 1, ''),
	(37, 'cNTFjYmVmNTkwZGE:', 0, 1445967948, 5, 5, 1446472357, 7, 6, 'Variablen', '[headline]Kapitel 6 - Variablen[/headline]\n\nNatürlich will man den Benutzer auch in die Programme einbeziehen. Das kann man z.B. indem man etwas, was der Benutzer schreibt einließt.\n[code]\nTextWindow.WriteLine("Geben sie bitte ihren Namen ein.")\nTextWindow.Read()\n[/code]\n\n[tasks]\nAufgabe1: [break]\n \n  [task]Probiere aus was dieser Code macht.[/task]\n \n[/tasks]\n\nWie du sicherlich gemerkt hast, kann man nun etwas über die Tastatur eintippen. Mit dem Befehl alleine kann man aber noch nicht so viel anfangen, da das was der Benutzer \neingibt nirgendwo abgespeichert wird(Der Rechner \'vergisst\' das also direkt nach dieser Codezeile wieder.). Um z.B. Benutzereingaben oder alle möglichen anderen Daten,\n wie z.B. Zahlen, Texte oder Objekt speichern zu können benutzt man [big]Variablen[/big]. \n \nVariablen kennst du vielleicht schon aus dem Matheunterricht(z.B.:a,b,x). Du kannst dir Variablen wie einen Korb vorstellen, in den du immer nur eine einzige Sache rein tun kannst. \n\nVariablen anlegen:\nUm etwas auf einer Variable zu speichern muss man diese erstmal anlegen. Man gibt ihr einen Namen, an den man erkennen sollte welchen Wert sie beinhaltet. Den Namen schriebt ihr am besten jetzt schon klein, keine Zahlen am Anfang,keine Leerzeichen und ohne Umlaute.\nDas macht man mit Variablenname=. Dann legt man auch noch den Wert den man speichern möchte auf ihr ab.\n[code]\ntext = "Hallo Welt!" 		\' auf der Variable text liegt der Text:"Hallo Welt" \nbenutzereingabe = TextWindow.Read()	\' die Variable benutzereingabe hat den Wert des Textes den der Benutzer eingibt\nzahl = 4 \' auf der Variable zahl liegt die Zahl 4\n[/code]\n\nDie Werte der Variablen kann man natürlich auch mit dem Befehl TextWindow.Writeline() ausgeben. Man kann einfach anstatt eines Textes den Variablennamen in die Klammern schreiben und \nder Wert der Variable wird ausgegeben. Bei Variablen lässt man allerdings die Anführungszeichen von TextWindow.Writeline("") weg, da diese kennzeichnen, dass eben ein Text darin steht und \nkeine Variable.\n\n[code]\nname = "Hans" \' Die Variable name wird angelegt und ihr wird der Wert Hans zugewiesen\nTextWindow.WriteLine(name) \' Der Wert der Variable (Hans) wird ausgegeben.\n[/code]\n\n[tasks]\nAufgabe2: [break]\n \n  [task]Lege eine Variable an aud der du einen beliebigen Wert ablegst. Nun benutze den Befehl TextWindow.Writeline() und schaue was passiert, wenn du darein einmal den Variablennamen \n  mit Anführungszeichen und einmal ohne Anfhürungszeichen packst. [/task]\n \n[/tasks]\n\nEs ist auch möglich mit dem Befehl TextWindow.Writeline() Texte und Variablenwerte zusammen auszugeben. Das ganze sieht dann so aus:\n[code]\nname = "Hans" \' Die Variable name wird angelegt und ihr wird der Wert Hans zugewiesen\nTextWindow.WriteLine("Dein Name ist" + name) \' Der Wert der Variable (Hans) wird ausgegeben.\n[/code]\n\n[tasks]\nAufgabe3: [break]\n \n  [task]Schreibe ein Programm, was den Namen des Benutzers einließt und danach Hallo und den eingegebenen Benutzernamen schreibt. [/task]\n \n[/tasks]\n\nMan kann zwar nur einen Wert auf einer Variable speichern, aber der Wert eine Variable kann mehrfach geändert werden.\nDas bedeutet es kann öfters dieselbe Variable ausgegeben werden und dennoch ein anderer Text angezeigt werden.\n\n[code]\nzahl = 5 \'zahl wird anglegt und auf 5 gesetzt\nTextWindow.WriteLine(zahl) \'der Wert von zahl,5, wird ausgegeben\nzahl= 14                        \'hier wird der Wert von Zahl auf 14 geändert\nTextWindow.WriteLine(zahl) \' der neue Wert von zahl,14, wird ausgegeben\n[/code]\n\nEs ist auch möglich den Wert den die Variable vorher hat in den neuen Wert einbeziehen:\n[code]\nzahl = 5 \'zahl wird anglegt und auf 5 gesetzt\nTextWindow.WriteLine(zahl) \'der Wert von zahl,5, wird ausgegeben\nzahl= zahl+4                       \'hier wird der Wert von zahl wird auf den vorherigen Wert von zahl (5) plus 4 gesetzt (9).\nTextWindow.WriteLine(zahl) \' der neue Wert von zahl,9, wird ausgegeben\n[/code]\n\n[tasks]\nAufgabe4: [break]\n \n  [task]Probiere folgendes Beispiel aus und schaue ob es funktioniert und ggf. was anders ist als beim Beispiel oben [/task]\n \n[/tasks]\n\n[code]\ntext= "Hallo"\nTextWindow.Writeline(text)\ntext= text+"Welt"\nTextWindow.Writeline(text)\n[/code]\n\n\n[tasks]\nAufgabe5: [break]\n \n  [task]Erstelle einen Taschenrechner, der zwei Zahlen erhält, diese addiert und dann wieder ausgibt. [/task]\n \n Aufgabe6: [break]\n \n  [task]Schreibe ein Programm, das 3 Zahlen von einander subtrahiert (= Minusrechnen). [/task]\n \n[/tasks]', 0, 0, '', 0, 0, 1, ''),
	(38, 'cOWIyNDI2ZTIxNzg:', 0, 1445967980, 5, 5, 1446472374, 7, 7, 'Verzweigungen', '[headline]Kapitel 7 - Verzweigungen[/headline]\nEs ist ja immer langweilig, dass die Programme immer das selbe macht. Um z.B. ein wenig Abwechslung zu haben benötigt man Verzweigungen. In diesen stehen Programmabschnitte, die nur unter bestimmten Bedingungen ausgeführt werden. Zum Beispiel, wenn ein Passwort richtig eingegeben worden ist.\n\nEine If-Bedingung kann man sich wie folgenden Satz vorstellen:\n\nWenn dein Name Hans ist, dann darfst du hier eintreten.\n[code]\nIf(deinName = "Hans") then \'so würde die Bedingung im Quelltext aussehen\n  	\'Alles was hier zwischen steht wird nur dann ausgeführt, wenn die oben aufgeführte Bedingung erfüllt ist\nEndIf\n[/code]\nHier wird als Vergleichszeichen das = benutzt. Dies ist dann erfüllt, wenn das was auf beiden Seiten steht gleich ist.\nUm z.B. Zahlen zu vergleichen gibt es noch das größer und kleiner Zeichen () und das größer gleich und kleiner gleich Zeichen (=). Das Gegenteil von gleich ist ungleich und wird so geschrieben .\n\nHier ein paar Beispiele, wann diese Sachen erfüllt sind.\n\n(5 = 5)		Fünf ist gleich fünf 			&#8594; erfüllt\n(3  5)		Drei ist kleiner als fünf 		&#8594; erfüllt\n(3  5)		Drei ist größer als fünf		&#8594; nicht erfüllt\n(5=5)		Fünf ist kleiner oder gleich fünf 	&#8594; erfüllt\n(2=3)		Zwei ist größer oder gleich drei	&#8594; nicht erfüllt\n\nWie ihr hier seht könnt ihr alles was man miteinander in Relation stellen kann wie Zahlen, Zeichenketten und somit auch Variablen (Eigenschaften kann man natürlich auch vergleichen) in Bedingungen verwenden. \nWenn ihr Zeichenketten verwendet (siehe Codebeispiel) achtet darauf, dass diese in Anführungszeichen setzt. So kann der PC zwischen Zeichenketten, Variablen und Zahlen unterscheiden.  \n\nWenn eine Bedingung erfüllt ist, dann ist sie true. Wenn nicht, dann ist sie false.\n\nFür die folgende Aufgabe benötigt ihr den Befehl [big]Clock.Hour.[/big] Dieser liefert die aktuelle Zeitstunde des Computers zurück.\n\n[tasks]\nAufgabe1:\n\n [task]Schreibt ein Programm, dass den Namen des Benutzers abfragt. Dann soll es folgendes ausgeben:\nWenn es vor 12 Uhr ist:	„Guten Morgen Name !“\nWenn es nach 12 Uhr ist: 	„Guten Nachmittag Name !“[/task]\n[/tasks]\n\nUm z.B. mehrere Bedingungen zu verbinden, kann man sie auch hintereinander stellen. Zum Verbinden gibt es zwei Varianten:\n\n[task] and - beide Bedingungen müssen erfüllt (true) sein[/task]\n[task] or - mindestens eine Bedingung muss erfüllt (true) sein[/task]\n\nFolgendes wäre erfüllt:\n((6=5)or(21)) \'Die erste Bedingung ist nicht erfüllt. Die zweite schon. Da aber für or nur eine erfüllt sein muss, ist beides erfüllt.\n\nDieses aber nicht\n((6=5)and(21)) \'Diese ist nicht erfüllt, weil hier beide erfüllt sein müssen. Da die erste nicht erfüllt ist und die zweite schon, ist dies nicht der Fall.\n\nWenn nun etwas ausgeführt werden soll, wenn die Bedingung nicht erfüllt ist, dann kann man anstatt Endif vorher noch else schreiben.\n\n[code]\nIf (Bedingung) then\n	\' wenn die Bedingung erfüllt ist wird dieser Teil ausgeführt\nelse	\'ansonsten\n	\'wird das ausgeführt\nEndif\n[/code]\n\nFür die folgende Aufgabe muss festgestellt werden, ob eine Zahl gerade oder ungerade ist. Dafür überprüft man, ob sie durch 2 teilbar ist.\nDies geht mit dem Befehl [big]Math.Remainder(zahl1,zahl2)[/big]. Zahl1 wird dann durch zahl2 geteilt und der Rest zurück geliefert. Ist der Rest = 0, so ist die Zahl durch 2 teilbar und somit gerade.\n\n[tasks]\nAufgaben2:\n\n [task]Schreibt ein Programm, bei dem man eine Zahl eingeben muss. Dann soll es sagen, ob die Zahl gerade ist ist oder nicht.[/task]\n [task]Schreibt ein kleines Quiz mit mindestens 5 Fragen, bei denen mehrere Antworten richtig sind.[/task]\n\n[/tasks]\n', 0, 0, '', 0, 0, 1, ''),
	(39, 'cZGM3ZDI1M2I2OTU:', 0, 1445968006, 5, 5, 1446472443, 7, 8, 'Schleifen', '[headline]Kapitel 8 - Schleifen[/headline]\nAngenommen wir möchten, dass unser Programm die Zahlen von 1 bis 100 nacheinander ausgibt.\n Für dieses Problem gibt es 2 Lösungen: \n\n[li]Wir schreiben 100 mal TextWindow.WriteLine(zahl).Was aber ziemlich umständlich ist und eigentlich nie verwendet wird.[/li]\n[li]Wir verwenden eine Schleife[/li]\n\n\nEine Schleife wiederholt einen Teil so oft bis eine Bedingung erfüllt ist. Sie besteht\nimmer aus einem Anfang und einem Ende. Diese definieren den Bereich der wiederholt werden soll. In den beiden folgenden Kapiteln lernt ihr 2 verschiedene Schleifenarten kennen.\nEinmal die For-Schleife und einmal die While-Schleife.', 0, 0, '', 0, 0, 1, ''),
	(40, 'cM2UxM2RiZDAwZWQ:', 0, 1445968023, 5, 5, 1446472472, 7, 9, 'For Schleife', '[headline]Kapitel 9 - For Schleife[/headline]\n\nDie For-Schleife zählt eine Variable hoch und wiederholt den Code in der Schleife bis eine angegebene Zahl erreicht wurde.\n\nDie For-Schleife sieht folgendermaßen aus:\n[code]\nfor i= 1 to 100 Step 1\n  \'Teil der wiederhohlt werden soll\nendfor\n[/code]\n\nMit i=1 sagt man, dass i hochgezählt werden soll und gibt i einen Startwert.Der Startwert muss nicht 1 sein sondern kann auch jede andere beliebige Zahl sein. Von diesem Startwert fängt die Schleife an zu Zählen und führt bei jedem Schritt den Code in der Schleife aus. \nNach dem man den Startwert festgelegt hat, muss man auch angeben bis wohin die Schleife zählen soll. Das macht man mit to "beliebige Zahl".\n Wenn die Schleife bei dieser Zahl angelangt ist bricht sie ab und wiederholt den Code nicht weiter.\n Das Step dahinter gibt lediglich an in welchen Schritten gezählt wird, also ob in 1ner, 2er etc. Schritten.\n \n\n\n[tasks]\nAufgabe1-5: [break]\n \n  [task] Schriebt ein Programm, was die Zahlen von 1 bis 55 ausgibt.[/task]\n  [task]Ändert das Programm so ab, dass alle Zahlen bis 55 ausgibt. Allerdings soll es erst bei 3 anfangen.[/task]\n  [task]Mit diesem Wissen sollt ihr jetzt ein Programm schreiben, dass alle ungeraden Zahlen von 100 aus rückwärts bis 1 anzeigt. Natürlich mit einer For-Schleife.[/task]\n  [task]Ändert Aufgabe 3 so ab, dess das Programm nur noch die Zahlen ausgibt die durch 3 teilbar sind. (Tipp:Verzweigungen)[/task]\n  [task]Scheibt ein Programm was von 1 bis 50 zählt und dann wieder runter von 50 zu 1.[/task]\n[/tasks]\n \n', 0, 0, '', 0, 0, 1, ''),
	(41, 'cNzE4NjJjMmNkODM:', 0, 1445968056, 5, 5, 1446472490, 7, 10, 'While Schleife', '[headline]Kapitel 10 - While Schleife[/headline]\nDa es auch manchmal Passieren kann, dass man am Anfang einer Schleife nicht weiß wie oft sie durchlaufen soll, gibt es die While-Schleife.\nDiese Arbeitet fast genauso wie die Schleife aus dem 1. Teil. Nur wird hier die If-Bedingung automatisch bei jedem durchlauf überprüft. Die Schleife läuft nur so lange durch, wie die Bedingung erfüllt ist.\n\n[code]\ni=1\nWhile (bedingung) \'z.B. i10 (solange i kleiner ist als 10)\n  Textwindow.WriteLine(i)\n  i=i+1\nEndWhile\n[/code]\n\n[tasks]\nAufgaben: [break]\n \n  [task]Nun schreibt ein Programm, dass eine Eingegebene Zahl solange durch 2 Teilt bis sie kleiner als 1 ist. Dabei soll jeder Zwischenschritt ausgegeben werden.[/task]\n  [task]Schreibt ein Programm, dass solange nach einem Passwort fragt, bis der Benutzer das richtige Passwort angegeben hat.[/task]\n \n[/tasks]  \n', 0, 0, '', 0, 0, 1, ''),
	(42, 'cM2M3OGNiMTUzNTQ:', 0, 1445968103, 5, 5, 1446472520, 7, 11, 'Schleifentest', '[headline]Kapitel 11 - Schleifentest[/headline]\n[tasks]\nAufgabe: [break]\n \n  [task]Jetzt könnt ihr testen, ob ihr die vorherigen 3 Kapitel verstanden habt; Schreibe ein Programm mit 2 Schleifen, das folgende Ausgabe auf dem Bildschirm erzeugt. [break]Tipp: Die Schleifen müssen "verschachtelt" werden. Das bedeutet die 2. Schleife wird von der 1. aufgerufen.[/task]\n \n[/tasks] \n\n', 0, 0, '', 0, 1, 1, ''),
	(43, 'cNWU3ZTllMzI0ODY:', 0, 1445968132, 5, 5, 1446472542, 7, 12, 'Turtle', '[headline]Kapitel 12 - Turtle[/headline]\nKommen wir nun zur Turtle (engl.: Schildkröte). Mit der Turtle hat man die Möglichkeit etwas grafisch darzustellen in der Form des Malens. Die Turtle bietet einem viele Möglichkeiten. Fangen wir mit einem leichten Beispiel an.\nMan kann die Turtle durch folgenden Befehl anzeigen lassen:\n[code]\nTurtle.Show()\n[/code]\nDas sollte dann so aussehen : \n\n\nDieser Befehl macht die Turtle unsichtbar, sie kann trozdem weiter Zeichnen.\n[big]Achtung[/big] Hat man die Turtle einmal verschwinden, lassen kann man sie nicht wieder sichtbar machen!!!\n[code]\nTurtle.Hide()\n[/code]\nDas ist natürlich noch sehr langweilig, man kann die Turtle nur sichtbar und unsichtbar machen. Aber man kann die Turtle auch auf viele verschiedene Arten bewegen, mit den folgenden Befehlen;\n[code]\nTurtle.Move(wie weit) \'bewegt die Turtle um X Pixel.\n[/code]\nNehmen wir als Beispiel:\n[code]\nTurtle.Move(100)\n[/code] \nDas sollte dann so aussehen : \n\n\n[code]\nTurtle.MoveTo(x,y) \'lässt die Turtle zum Punkt(x,y) bewegen.\n[/code]\nUnd man hat viele Möglichkeiten die Turtle zu drehen, z.B.:\n[code]\nTurtle.TurnRight \'dreht die Turtle nach Rechts\nTurtle.TurnLeft \'dreht die Turtle nach Links\nTurtle.Turn(Winkel)  \'dreht die Turtle um einen gewissen Winkel\nTurtle.Angle(Winkel) \'dreht die Turtle um einen gewissen Winkel (wie bei .Turn)\n[/code]\nUm die Geschwindigkeit der Turtle zu ändern benutzt man:\n[code]\nTurtle.Speed(Zahl)\n[/code]\nDie Zahl darf nur einen Wert Zwischen 1-10 haben.\nSchauen wir uns folgende Befehle an:\n[code]\nTurtle.PenUp()\nTurtle.PenDown()\n[/code]\nDiese beiden Befehle sind da um den "Stift" der Turtle hoch zu nehmen (also nicht zu Zeichen) oder wieder runter zu tun (also Zeichen).\nMan kann also eine gewisse Strecke mit der Turtle fahren ohne zu Zeichnen.\n\nTurtle.X bzw Turtle.Y lässt die Turtle zu einem gewissen Punkt springen. Hat man z.B.\n[code]\nTurtle.X = 100\nTurtle.Y = 100 \n[/code]\nIst die Turtle auf dem Punkt(100,100).\nSetzt man nun nur Turtle.X oder Turtle.Y auf einen anderen Wert so behält die Turtle den X bzw Y Wert und ändert nur den angegeben Wert. z.B.\n[code]\nTurtle.X = 100\nTurtle.Y = 100\nTurtle.X = 200\n[/code]\nSo steht z.B. die Turtle zum Schluss auf dem Punkt (X=200,Y=100) da sich der Y-Wert kein zweites mal ändert.\n[tasks]\nMache mindestens eine der folgenden Aufgaben : [break]\n \n  [task]Zeichne mit der Turtel einen Kreis.[/task]\n  [task]Zeichne das Haus vom Nikolaus [/task]\n  [task]Zeichne mit der Turtle ein Haus dessen Höhe vorher vom Benutzer eingegeben wurde.[/task]\n  [task]Lasse den Benutzer die Turtel steuern, er soll nach jedem Schritt eingeben wie weit und in welche Richtung die Turtel gehen soll(\'R\',\'L\',\'O\',\'U\') bis er \'Stopp\' eingibt.(Schwer)[/task]\n \n[/tasks] \n \n', 0, 0, '', 0, 0, 1, ''),
	(44, 'cODFmOWY0ZDIxYjU:', 0, 1445968159, 5, 5, 1446472563, 7, 13, 'Arrays', '[headline]Kapitel 13- Arrays[/headline]\nWie ihr wisst speichert man in Variablen immer einzelne Sachen, wie etwa : AnzahlderKekse, Benutzername etc.[break]\nWas tut man jedoch, wenn man von mehrere Benutzer den Namen haben möchte oder von verschiedenen Keksdosen die Keksanzahl speichern möchte?[break]\nFür diesen Fall gibt es [big]Arrays[/big]. Sie sind eine Variable in der man mehrere Werte Speicher kann. Diese werden einfach durchnummeriert.[break]\nDas ganze sieht dann so aus:[break]\n[code]\nBenutzer[1] = Tim[break]\nBenutzer[2] = Nils[break]\nBenutzer[3] = Tom[break]\n...[break]\nBenutzer[x] = ...[break]\n[/code]\nAlso zusammengefasst: [break]\n[big]Arrayname[index] = Wert[/big][break]\nHierbei steht index für die Stelle im [big]Array[/big] wo der Wert liegt.[break]\n[tasks]\n\n[task]Formuliert 5 verschiedene Arrays wie Benutzernamen, Kästen etc.[break]\n\n[/tasks]\nDas nützliche an [big]Arrays[/big] ist, dass vorher nicht wissen muss, wie viele Einträge man braucht.[break]\nWo man früher etwas ind er Art von: Benutzereins, Benutzerzwei, Benutzerdrei etc. schreiben musste kann man jetzt einfach ein [big]Array[/big][break]\nBenutzer benutzen.[break]\n\nDies hat noch weitere Vorteile, so kann man etwa neue Benutzer ganz schnell einlesen. Möchten wir 10 neue Benutzer haben schreiben wir folgendes:[break]\n\n[code]\nFor i = 1 to 10[break]\n	Benutzer[i] = Textwindow.read()[break]\nEndFor[break]\n[/code]\nMöchten wir dies jetzt später ausgeben, so schreiben wir einfach[break]\n[code]\nFor i = 1 to 10[break]\n	Textwindow.writeline(Benutzer[i])[break]\nEndFor[break]\n[/code]\n[tasks]\n\n[task]Schreibt ein Programm, welches zuerst 5 Benutzer und ihr dazugehöriges Passwort einliest, und diese beide dann nacheinander ausgibt.[break]\n[task]Erweitert dieses Programm: Die Namen und Passwörter sollen nichtmehr ausgegeben werden, dafür soll solange Abgefragt werden,\n bis jemand einen Benutzernamen und das dazugehörige Passwort eingibt.[break]\n \n [/tasks]\n \n', 0, 0, '', 0, 0, 1, ''),
	(45, 'cOTQ5ZTdlNGZhYzE:', 0, 1445968174, 5, 5, 1446472580, 7, 14, 'Subs', '[headline]Kapitel 14- Subs[/headline]\nSehr oft kommt es vor, dass eine bestimmte Folge an Befehlen öfters vorkommt. Es ist auch lästig diese immer wieder hintereinander\n zu schreiben. Wäre es da nicht praktisch all diese Zeilen zusammenzufassen und mit nur ein paar Buchstaben aufzurufen?\nDas geht, denn dafür gibt es die Sub´s. Diese kann man als eine Art Unterprogramm sehen. Sie beginnen mit dem Befehl Sub und enden mit dem Befehl\n EndSub. Alles was zwischen den beiden Befehlen steht, ist das, was das Unterprogramm machen soll. Damit man es auch  noch\n ansprechen kann, muss man jeder Sub einen Namen geben. Dies geschieht hinter dem Wort Sub. Dort kommt ein sinnvoller Name\n hin, der am Besten das, was die Sub macht, gut zusammenfasst.\nMan ruft diese Sub einfach auf, indem man an der Stelle, wo die Befehle ausgeführt werden sollen, einfach den Namen der Sub\n schreibt und danach eine Klammer auf und eine zu macht. Das ganze könnte dann so aussehen:\n[code]\nzahleingebenlassen() \'Ruft die Sub zahleingebenlassen auf\n\nSub zahleingebenlassen\n  zahl = Textwindow.Readnumber()\nEndSub\n[/code]\n\n[tasks]\nAugabe1:\n\n[task]Lagert nun die Passwortabfrage aus Kapitel 13 in ein Sub aus, es soll also beim Aufruf von Passwordabfrage() ein "Benutzer und Password sind korrekt ausgegeben werden, [break]\nwenn die Daten im Array vorhanden sind, und ein "Benutzer oder Password falsch" wenn sie es nicht sind.\n\n[/tasks]\n \n', 0, 0, '', 0, 0, 1, ''),
	(46, 'cMTVhYTIyNjcyNzk:', 0, 1445968197, 5, 5, 1446472621, 7, 15, 'Buttons und Ereignisse', '[headline]Kapitel 15 - Buttons und Ereignisse[/headline]\n\nUm ein Programm besser zu gestalten, reicht es nicht, dem Computer andauernd Befehle zu erteilen, die er dann \nausführen soll. Deshalb ist es auch wichtig, [big]Ereignisse[/big] zu benutzen. Bei einem Ereignis führt der Computer\nSubs erst dann aus, wenn ein Ereignis eintritt. Ein Ereignis ist zum Beispiel, wenn ein Button gedrückt wird.\n\nFolgendes Beispiel:\n\n[code]\nGraphicsWindow.MouseDown = KlickEreignis \'Ruft die Sub KlickEreignis auf, wenn die Maustaste auf das GraphicsWindow geklickt wird\n\nSub KlickEreignis\n  GraphicsWindow.ShowMessage("Es wurde geklickt!")\nEndSub\n[/code]\n\nStatt einer Eigenschaft von GraphicsWindow wurde hier ein Ereignis angegeben: [big]MouseDown[/big]. Das bedeutet,\n sobald man auf das GraphicsWindow klickt, wird die Sub \n KlickEreignis aufgerufen. Man kann so oft drücken wie man will. Es wird immer das Selbe passieren.\n\n[tasks]\nAufgabe: \n\n	[task]Macht euch mit den Ereignissen MouseDown, MouseUp, MouseMove, KeyDown und KeyUp vertraut und notiert euch, wann diese Ereignisse eintreten.[/task]\n\n[/tasks]\n\nDiese Ereignisse werden meist in Verbindung mit Buttons verwendet. Buttons kann man mit dem Befehl "Controls.AddButton(Text,x,y)" hinzufügen.\nDas könnte dann so aussehen:\n\n[code]\nControls.AddButton("Hallo!",30,30)\n[/code]\n Bei dem Befehl AddButton gibt es 3 Parameter, die man angeben muss:\n\n [li] Die Beschriftung, was auf dem Button stehen soll (auch "Caption" genannt)[/li]\n [li] Die X-Koordinate des Buttons[/li]\n [li] Die Y-Koordinate, wo der Button sein soll.[/li]\n\n\nEin Button an sich bringt aber noch nicht viel. Schließlich soll ja auch was passieren wenn man auf ihn drückt. \nDazu braucht ihr eines der eben angesprochenen Ereignisse, in diesem Fall wäre es ButtonClicked. Das Ereignis Buttonclicked tritt immer ein, wenn ein Button geklickt wird, EGAL welcher Button es ist. Diesem Ereignis weist ihr eine Sub zu, die ausgeführt wird, wenn auf den Button geklickt wird. \n\n[code]\nControls.AddButton("Hallo!",30,30)\nControls.ButtonClicked = Halloruf \'Ruft das Ereignis Halloruf auf, wenn auf einen Button geklickt wird\n\nSub Halloruf\n  GraphicsWindow.ShowMessage("Hallo!")\nEndSub\n[/code]\n\nHier wird bei dem Befehl ButtonClicked die Sub Ereignis aufgerufen, die wiederum ein Fenster erscheinen\n lässt. Wichtig: Ihr müsst bei dem Ereignis ButtonClicked eine Sub angeben, die beim Buttonklick aufgerufen werden soll, sonst funktioniert es nicht.\n\nIhr könnt so viele Buttons machen wie ihr wollt. Aber ihr könnt dem Ereignis ButtonClicked nur eine einzige\n Sub zuweisen. Das Ereignis Buttonclicked ist also für ALLE Buttons zuständig. Die Sub wird also immer aufgerufen, egal welcher Button gedrückt wird. Falls ihr dem Ereignis Burroncklicked mehrere Subs zuweist, wird immer die letzte aufgerufene Sub ausgeführt.\nSelbst bei 100 Buttons, 100 Subs und 100 ButtonClicked wird immer die zuletzt angegebene Sub, also die 100. Sub, ausgeführt.\n\nBeispiel für 2 Buttons:\n[code]\nControls.AddButton("Hallo!", 50, 20)\nControls.ButtonClicked = Ereignis\nControls.AddButton("Tschüss!", 20, 50)\nControls.ButtonClicked = Ereignis2\n\nSub Ereignis \n  GraphicsWindow.ShowMessage("Sie haben geklickt!", "Hallo!")\nEndSub\nSub Ereignis2 \n  GraphicsWindow.ShowMessage("Auf Wiedersehen!", "Tschüss!")\nEndSub\n[/code]\n\nMöchte man aber wissen, welcher Button zuletzt geklickt wurde, kann man dies mit dem Befehl Controls.LastClickedButton herausfinden.\n\nEs ist auch möglich, Textfelder einzufügen und mit diesen zu arbeiten. Mit dem Befehl "Controls.AddTextBox(x,y)" kann man ein Eingabefeld erzeugen. Genau wie beim Button\nmuss man auch hier X- und Y-Koordinaten angeben. Soll die Textbox einen Namen bekommen, muss die Box an sich in einer Variable gespeichert werden.\n\n[tasks]\nAufgaben: \n\n        [task]Erstelle ein Programm mit 2 Buttons, das ausgibt, welcher der beiden Buttons gedrückt wurde. Als Erweiterung soll beim Klicken des ersten Buttons eine Showmessage ausgegeben werden. Der Inhalt der Showmessage soll variieren, je nachdem, welcher Button geklickt wurde. Tipp: Hier hilft eine If-Abfrage.\n [/task]	\n        [task]Probiere den Befehl AddTextBox aus. Verwende auch einmal die Befehle Controls.SetTextBoxText(Name,Text) und Controls.GetTextBoxText(Name). Notiere und merke dir, was diese Befehle machen und was man mit ihnen machen kann.\n [/task]\n	[task]Schreibe ein Programm, das beim Klick auf einen Button das, was in einem Textfeld steht, im Textwindow ausgibt. Benutze dafür die Befehle, die du gerade in Aufgabe 2 kennengelernt hast.\n       \n[/task]\n \n [/tasks]\n', 0, 0, '', 0, 0, 1, ''),
	(47, 'cY2U4OTFmYzU4NGQ:', 0, 1445968214, 5, 5, 1446472638, 7, 16, 'Shapes', '[headline]Kapitel 16 - Shapes[/headline]\nIn unseren Programmen wollen wir auch verschiedene Objekte auf dem Bildschirm anzeigen, die z.B. der Spieler beeinflussen kann. \nMit [big]Shapes[/big] lassen sich solche Objekte erstellen. Mit dem Befehl [big]Shapes.AddEllipse()[/big] wird ein Kreis erstellt. [break]\n\nUm die Position des Kreises zu bestimmen wird [big]Shapes.Move()[/big] benutzt. Move erfordert als Parameter den Namen des Kreises, sowie die x- und y-koordinate des Kreises, bzw. Shapes.\nDer Name wird dem Kreis beim erstellen zugewiesen und sollte sinnvoll gewählt werden. Außerdem müssen in der Klammer die Höhe und breite festgelegt werden.\nHier ein Beispiel:\n[code]\nObjekt1 = Shapes.AddEllipse(50,50)\n\nShapes.Move(Objekt1,400,200)\n[/code]\n[break]\n\nMit Shapes können nicht nur Kreise oder Ellipsen erstellt werden, sondern auch Recht- oder Dreiecke. Dafür bedarf es der Befehle [big]Shapes.AddRectangle()[/big] oder [big]Shapes.AddTriangle()[/big].\nAllerdings wird bei Triangle nicht Höhe und Breite benötigt, stattdessen müssen die Koordinaten der Eckpunkte des Dreiecks angegeben werden.\n[tasks]\nAufgabe: \n\n	[task]1.Versuche eine Ellipse, ein Rechteck und ein Dreieck zu erstellen und an verschiedenen Positionen zu positionieren.[/task]\n        [task]2.Erstelle ein Programm welches einen Kreis an der Position deines Mausezeigers erstell, wenn du mit der linken Mausetaste klickst. Die Mausposition erhältst du mit Mouse.MouseX und Mouse.MouseY. Behalte deinen Code bis Aufgabe 12b.3[/task]\n\n[/tasks]\n\n', 0, 0, '', 0, 0, 1, ''),
	(48, 'cODlhMjhkYmNhYzc:', 0, 1445968231, 5, 5, 1446472661, 7, 17, 'Shapes bewegen', '[headline]Kapitel 17 - Shapes bewegen[/headline]\nShapes können nicht nur an einer Stelle erstellt werden, sondern mit Shapes.Move auch noch später bewegt werden.\nMan könnte beispielsweise einen Kreis mit den Tasten W,A,S und D bewegen. \nDazu bedarf es zuerst einmal dem Ereigniss [big]GraphicsWindow.KeyDown[/big], welches ausgelöst wird, wenn auf eine Taste gedrückt wird.\nIn der zugewiesenen Sub kann abgefragt werden (If), welche Taste gedrückt wird und je nach Taste etwas anderes ausgeführt werden. \nWelche Taste zuletzt gedrückt wurde ist unter [big]GraphcsWindow.LastKey[/big] gespeichert.\n[break] \n\n[code]\nSub Tastendruck\n  If (GraphicsWindow.LastKey = "D") Then \n    ...\n  EndIf\n[/code]\n[break]\n\nBei Move muss der Kreis dann zu seiner aktuellen Position + einen festgelegten Wert bewegt werden.\nDie aktuelle X-, Y-koordinate erhält man mit [big]Shapes.GetLeft[/big] und [big]Shapes.GetTop[/big].\n[break] \n\n[code]\n  Shapes.Move(Objekt1,Shapes.GetLeft(Objekt1)+5,Shapes.GetTop(Objekt1))\n[/code]\n[break]\n\n\nEine weitere Möglichkeit zum Bewegen ist ein [big]Timer[/big]. Dieser erhält mit [big]Timer.Intervall[/big] ein Zeitfenster, nach dessen Ablauf ein Ereigniss ausgelöst wird.\nDieses Ereigniss wird mit [big]Timer.Tick[/big] festgelegt. Der Timer funktionier also ähnlich einer Eieruhr, nach einer gewissen Zeit geschieht etwas. \nWird ein Shape vom Timer alle 100 Millisekunden bewegt, so entsteht eine recht flüssige bewegung.\n[break]\n\n[code]\n  Timer.Intervall = 100\n  Timer.Tick = meinTimer\n\n  Sub meinTimer\n    ...\n  EndSub\n[/code]\n[break]\n\nIn diesem Beispiel wird durch den Timer eine Sub mit Textausgabe Timer alle 2000 Millisekunden also alle 2 sek aufgerufen.\n[code] \nTimer.intervall = 2000\nTimer.tick = textausgabe\n\n\nSub textausgabe \n TextWindow.Writeline("2sek sind vergangen")\nEndSub\n[/code]\n[tasks]\nAufgabe: \n\n	[task]Erstelle einen Kreis der mit den Taste A und D nach rechts und links über den Bildschirm laufen kann.[/task]\n        [task]Verändere dein Programm und lasse den Kreis mit einem Timer von Bildschirmrand zu Bildschirmrand laufen. Ändere die Richtung immer, wenn er den Rand erreicht. Tipp: verwende eine Variable als Werte um den der Kreis bewegt wird.[/task]\n        [task]Modifiziere Aufgabe 16a.2 so, dass die Kreise durch einen Timer mit dem Befehl Shapes.Zoom immer größer werden.[/task]\n\n[/tasks][break]', 0, 0, '', 0, 0, 1, ''),
	(49, 'cODg3ZWE3N2JmZWQ:', 0, 1445968253, 5, 5, 1446472677, 7, 18, 'Große Aufgabe', '[headline]Kapitel 18 - Große Aufgabe[/headline]\nIn diesem Kapitel werdet ihr euer erstes Spiel Programmieren.[break]\nEs soll ein Tic-Tac-Toe Spiel Programmiert werden, welches man mit Buttons Spielt, [break]das heißt jedes der neun felder ist ein Button.[break]\nDas Spiel sollte in etwa so aussehen :[break]\n\n[break]\nEs muss nicht genau so aussehen, es sollte jedoch so ähnlich aussehen.[break]\n\n[tasks]\nTipps:\n\n[task]Arbeitet mit Buttons, die ihr als Spielfelder benutzt.[/task]\n[task]Benutz Subs das erleichtert Arbeit.[/task]\n[task]Benutzt viele Verzweigungen, IF-Abfragen.[/task]\n[/tasks]\n\n\n\n', 0, 0, '', 0, 1, 1, ''),
	(55, 'cMWJjMGVkZjBmMmQ:', 0, 1446468785, 5, 5, 1446468785, 3, 1, 'Einleitung', '[headline]Kapitel 0 - Einleitung[/headline]\r\n\r\nMit diesem Programm kann man verschiedene Inhalte Kapitel für Kapitel lernen. Zu dem kompletten Delphi-Lehrgang muss jede Schülerin bzw. Schüler eine Mappe anlegen und dort gelerntes niederschreiben. Die Mappe muss ein Deckblatt, ein Inhaltsverzeichnis, die einzelnen Inhalte und eine Befehlsreferenz aller erlernten Anweisungen erhalten. Die Mappe wird zum Schluss eingesammelt. Sollte es Schülerinnen / Schüler geben, die schon jetzt richtig gut programmieren können, so erhalten diese eine andere Aufgabe. Sie müssen dann weder die Mappe abgeben, noch die Aufgaben dieser Kapitel bearbeiten. Allerdings müssen sie den Stoff aller Kapitel beherrschen oder in ihrer Freizeit aufarbeiten. \r\n\r\n\r\nDieses Kapitel soll euch kurz erläutern, was ihr in den folgenden Kapiteln überhaupt lernen werdet. Das ist eine ganze Menge. Die jenigen unter euch, die schon programmieren können, werden die ersten Kapitel ziemlich schnell bearbeiten. Wer noch nicht programmieren kann, der wird genau dies hier lernen. Programmieren ist im Grunde ein ganz tolle Sache, da so eigene Programme erstellen kann. Das können Scherzprogramme sein, um jemanden zu ärgern, Spiele, kleine Anwendungen, die den Alltag erleichtern und noch vieles mehr. Wichtig: Ihr lernt hier in erster Linie das Programmieren und nicht nur die Sprache Delphi. Programmieren kann man nämlich in vielen Sprachen, zum Beispiel: C, C++, C#, Java, Visual Basic, Javascript, Pascal, Assembler, PHP und auch in Delphi. [break]\r\nEs bleibt die Frage, wie das geht? Im Grunde ist das nicht schwer: Man gibt dem Rechner einfach eine ganze Menge Anweisungen, die dieser Schritt für Schritt befolgen ausführt. Dabei muss man mit dem PC, wie mit einem Kleinkind sprechen und ihm alles ganz genau sagen, was er tun soll. Von alleine macht der nämlich nichts. Man muss es ihm sagen. [break] [break]\r\nNehmen wir uns ein Beispiel: Eine ToDo-Liste. Du findest ein Zettel deiner Mutter auf deinem Bett: [break]\r\nBitte mache noch folgendes:\r\n\r\n \r\n [li] Dein Zimmer aufräumen [/li]\r\n [li] Deine Hausaufgaben machen [/li]\r\n [li] Mit Charlie gassigehen [/li]\r\n [li] Vokabeln üben [/li]\r\n\r\n\r\nSo funktioniert auch das Programmieren. Man schreibt eine Liste und der Rechner arbeitet diese ab. Jetzt gibt es da noch ein paar [big]Kontrollstrukturen[/big], die das einfache Abarbeiten von Anweisungen beeinflussen. Hier wieder ein Beispiel: \r\n\r\n \r\n [li] Dein Zimmer aufräumen [/li]\r\n [li] Deine Hausaufgaben machen [/li]\r\n [li] Mit Charlie gassigehen [/li]\r\n [li] Wenn du Vokabeln noch nichts kannst, dann musst du diese üben, sonst machst du statt dessen Matheübungen [/li]\r\n\r\n\r\nDies nennen wir eine [big]Verzweigung[/big], da sich hier der Kontrollfluss verzweigt und nur ein "Weg" genommen wird: Du beginnst brav und räumst dein Zimmer auf, dann machst du die Hausaufgaben, dann führst du Charlie aus. Nun kommt es drauf an: Kannst du schon die Vokabeln oder nicht? Es gibt 2 Möglichkeiten (ja oder nein), je nach dem, machst du anders weiter (Verzweigung): Du übst Vokabeln oder machst Mahtematik. [break][break]\r\n\r\nNeben der Verzweigung gibt es auch eine weitere Kontrollstruktur: [big]Die Schleife[/big]. Manche Mütter benötigen diese auch bei ihren ToDo-Listen, da ihr Kind sonst nach 5 Minuten Vokabelnlernen schon aufhört und meint, es hätte doch nun Vokabeln gelernt. Daher sieht die Liste dann so aus:\r\n\r\n \r\n [li] 1. Dein Zimmer aufräumen [/li]\r\n [li] 2. Deine Hausaufgaben machen [/li]\r\n [li] 3. Mit Charlie gassigehen [/li]\r\n [li] 4. Lerne deine Vokabeln [/li]\r\n [li] 5. Überprüfe, ob du wirklich alle Vokabeln kannst, sonst mache weiter bei Punkt 4[/li]\r\n\r\n\r\nBei einer Schleife gibt es einen [big]Codeblock[/big], der ggf. mehfach wiederholt wird (hier Zeile 4) und eine [big]Abbruchbedingung[/big], die festlegt, wenn die Schleife verlassen wird (hier Zeile 5). [break][break]\r\n\r\nNeben den Kontrollstrukturen gibt es auch noch \r\n\r\n [li] [big]Variablen[/big], in denen unter anderem Zahlen und Texte abgelegt werden können.[/li]\r\n [li] [big]Proceduren[/big], mit denen man quasi mehrere Anweisungen zusammenfassen kann[/li]\r\n [li] [big]Funktionen[/big], die verschiedenste Sachen berechnen oder auswerten[/li]\r\n\r\n\r\nAlle "normalen" Programmiersprachen besitzen diese Elemente. Könnt ihr gut in Delphi programmieren, dann könnt ihr auch schnell weitere Sprachen lernen. Es ändert sich quasi nur hier und da das Vokabular. Die Grammatik ist im Grunde die Gleiche. [break][break]\r\n\r\nBevor es jetzt so richtig los geht, möchte ich an dieser Stelle noch einige gute Links angeben:[break]\r\nWenn ihr mal was nicht versteht, so könnt ihr auch in einem anderen Tutorial nachschlagen    gutes Tutorial  [break]\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Erstelle (auf Papier) eine Spickanleitung mit Verzweigungen und Schleifen. Diese soll vom Aufbau her wie obige ToDo-Liste sein.[/task]\r\n  [task]Lade dir die kostenlose Delphi-Version "Turbo Delphi" herunter und installiere sie bei dir zu Hause. Eine Anleitung zum Download \r\n      findest du hier:  hier  [break] Wichtig: Es müssen 2 Dateien runtergeladen werden![/task]\r\n \r\n[/tasks]\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, dass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n', 0, 0, '', 0, 0, 1, ''),
	(56, 'cZGY4NzdjM2M1YmY:', 0, 1446468800, 5, 5, 1446468800, 3, 2, 'Compiler un Co', '[headline]Kapitel 1 - Compiler und Co[/headline]\r\n\r\nWie funktioniert so eine Sprache überhaupt? [break]\r\nDer Computer versteht nur [big]Maschinencode[/big]. Das sind für uns nur scheinbar zufällig angeordnete, kryptische Zeichen. Für den Rechner super, der kann diese nämlich ganz schnell verarbeiten, für den Menschen aber nicht zu beherrschen. Da der Rechner aber nur diesen Maschinencode versteht, bedarf es höherer Programmiersprachen (wie zum Beispiel Delphi). Diese kann der Mensch bequem programmieren. Es bleibt daher nur noch die Frage, wie wird aus dem Delphi-[big]Quellcode[/big], also was der Programmierer schreibt, Maschinencode? Dafür gibt es drei Möglichkeiten. [break][break]\r\n\r\nEs gibt die [big]Compilersprachen[/big], die den ganzen Quellcode mit Hilfe eines [big]Compilers[/big] in Maschinencode übersetzen. Es entsteht eine ausführbare (exe-) Datei. Schaut man mal mit einem Editor in eine solche Datei (bitte nicht speichern), dann sieht man den Maschinencode. Wer diesen lesen und zurückübersetzen kann, der bekommt von mir einen Kasten Cola ausgegeben. [break]\r\nBeispiele solcher Compilersprachen sind C, C++, Delphi oder auch Pascal. [break][break]\r\n\r\nDann gibt es noch die Interpretersprachen. Hier wird der Code nicht durch einen Compiler komplett übersetzt, sondern nur Zeile für Zeile durch einen Interpreter in Maschinencode umgewandelt und direkt ausgeführt. Dafür bedarf es also immer ein Programm, dass den Code ausführt, einen so genannten [big]Interpreter[/big]. Diese Sprachen sind in aller Regel etwas langsamer, haben aber auch ihre Vorteile. Sie können meist auf unterschiedlichen Betriebssystemen gestartet werden, da es für viele Betriebsysteme (Windows, Linux, evtl. MacOs, ...)einen entsprechenden Interpreter gibt, der den Quellcode interpretiert.[break]\r\nBeispiele solcher Sprachen sind zum Beispiel: BASIC, PHP, Javascript oder auch Perl.[break][break]\r\n\r\nDie letzte Möglichkeit ist eine Mischung aus beiden und ist in letzter Zeit in Mode gekommen. Man möchte die Möglichkeit nutzen, das Programm auf verschiedenen Plattformen (unterschiedliche Hardware, unterschiedliches Betriebssystem) nutzen zu können. Andererseits soll das Programm auch komplexe Aufgaben möglichst zeiteffizient bewältigen. Die Lösung: Man compiliert den Quellcode in so genannten [big]Bytecode[/big]. Dieser ist schon recht Maschienennah und man kann ihn auch nicht mehr entziffern, aber er ist noch so unspezifisch, dass er noch auf unterschiedlichesten Plattformen ausgeführt werden kann. Diesbezüglich ist aber auch hier ein Interpreter nötig, der den Code letztlich ausführt. [break]\r\nBeispiele für solche Programmiersprachen sind: Java, C# und Python.\r\n\r\nEs ist wichtig, die einzelnen Komponenten einer Programmiersprache auseinanderzuhalten. Bei Delphi gibt es zum Beispiel eine Umgebung, quasi ein umfangreicher Editor, in den man programmieren, [big]debuggen[/big](Fehler suchen) und auch direkt ausführen kann. Diese Umgebung nennt man auch [big]IDE[/big] (von engl. integrated development environment). Rein theoretisch könnte man aber auch nur in einem Editor arbeiten. Neben der IDE gibt es noch den Compiler, das eigentliche Wunderwerk und die Sprache an sich. Diese definiert, wie welche Anweisungen heißen und nach welchen Regeln diese wie aneinandergereit werden. Alle drei Komponenten (Sprache, Compiler, IDE) unterliegen einem Entwicklungsprozess und ändern sich daher von Zeit zu Zeit. Die Sprache bekommt neue Anweisungen hinzu, die IDE bekommt andere Fenster und Tools und der Compiler muss die neuen Anweisungen verarbeiten können und wird auf die neue Hardware optimiert.\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task](opt) Erkundige dich im Internet über das Thema Compiler und Linker[/task]\r\n \r\n[/tasks]\r\n\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, dass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n', 0, 0, '', 0, 0, 1, ''),
	(57, 'cYWFhN2Q2NjcwZGU:', 0, 1446468834, 5, 5, 1446468834, 3, 3, 'Hello World', '[headline]Kapitel 2 - Hello World[/headline] \r\n\r\nZunächst startet man Turbo Delphi. Dann klickt man auf neues Projekt. Jetzt hat man die Auswahl, was man überhaupt entwickeln möchte. Delphi stellt inzwischen unheimlich viele Möglichkeiten bereit. Für uns und die Schule reicht eine "VCL-Formularanwendung". Hier kann man ohne Eingabe von Programmiercode die Oberfläche für sein Programm zusammenklicken. Die IDE erzeugt dann automatisch den Code für das Fenster. So ist es möglich, ganz schnell ein [big]Formular[/big] (Fenster) mit Knöpfen, Auswahllisten und Textfeldern zu erstellen. Klickt also auf "VCL-Formularanwendung".[break]\r\nBevor wir jetzt groß etwas programmieren, speichern wir zunächst das [big]Projekt[/big] ab. Aber Achtung: Es handelt sich dabei um eine Projekt-Datei mit der Endung ".bdsproj". Im Gegensatz zu einfachen kleinen Sprachen, wie z.B. Pascal, besteht bei Delphi schon eine kleine Anwendung aus vielen Dateien. Da gibt es:\r\n\r\n [li]Die Projektdatei, die quasi alles zusammenhält ".bdsproj"[/li]\r\n [li]Der Programmcode, der die Fenster initalisiert ".dpr"[/li]\r\n [li]Jedes Fenster (eine Anwendung kann mehrere Fenster haben) besitzt:\r\n   \r\n     [li]Das Layout des Fensters ".dfm"[/li]\r\n     [li]Den Programmiercode, der zu Aktionen des Fensters gehört ".pas"[/li]\r\n   \r\n [/li]\r\n [li]Und noch viele weitere Dateien[/li]\r\n\r\n\r\nDeshalb ist es so wichtig, dass man zu jedem neuen Projekt einen eigenen Unterordner erstellt.[break][break]\r\n\r\nDesweiteren sollte man sein Projekt sinnvoll benennen. Daher macht ihr jetzt folgendes:[break]\r\n[big]\r\n  [li]Datei - Alles speichern [/li]\r\n  [li]Das richtige Verzeichnis aussuchen: Das ist euer Unterordner im IAHK-Verzeichnis!!![/li]\r\n  [li]Dort einen Unterordner für das Projekt anlegen, z.B. "HelloW" [/li]\r\n  [li]Einen geeigneten Namen für das Fenster angeben, z.B. "HelloW.pas" [/li]\r\n  [li]Einen geeigneten Namen für das Projekt angeben, z.B. "Prj_HelloW.bdsproj" [/li]\r\n[/big]\r\n\r\nDas Projekt darf nicht den gleichen Namen haben wie eines seiner "Fenster". Später, wo wir mit mehreren Fenster arbeiten, ist es wichtig, gute Namen für die Fenster zu haben. Generell werden wir beim Programmieren immer wieder zu den Punkt kommen, wo wir Funktionen, Proceduren, Variablen, Klassen oder Units Namen geben müssen. Diese müssen gut gewählt werden! Es gehört zum guten Programmierstil.[break][break]\r\n\r\n [break][break]\r\n\r\nJetzt erstellen wir uns einen Button auf dem Formular.  Dafür gehen wir rechts auf die Toolpalette und wählen dort "TButton". Dann gehen wir mit dem Mauszeiger in der Mitte auf das Formular und ziehen uns dort einen Button. Im Objektinspektor (links) können wir die Eigenschaften des Knopfes sehen. Jedes so erstellte Objekt erhält automatisch einen Namen, in diesem Fall Button1. Später sollte man bei den Eigenschaften, sobald man sich einen solches Feld auf das Formular legt, den Namen entsprechend ändern, z.B. nach OK_Button, damit man weiß, um welchen Knopf es sich handelt. Der Einfachheit halber lassen wir aber zunächst den Namen bei Button1. Betrachten wir weiter die Eigenschaften im Objektinspektor. Diese Eigenschaften kann man dort auch ändern. So kann man zum Beispiel auf "Caption" und dort den angezeiten Text auf dem Knopf ändern.  Ändere den Text des Knopfes auf OK. Dann klicke auf das Formular an sich (also nicht auf den Button). Jetzt sollte im Objektinspektor die Eigenschaften des Formulars stehen.  Ändere auch hier einmal die Eigenschaft "caption" und die Eigenschaft "Color". Letztlich ziehst du noch ein TEdit-Feld auf dein Formular. [break]\r\nFertig![break]\r\nNun führen wir dieses Programm einmal aus, indem wir oben in der IDE auf den grünen Pfeil (Play, bzw. Start) klicken. [break]\r\nJetzt sollte das Fenster erscheinen. Man kann den Text im Textfeld anklicken und verändern. Außerdem kann man den "OK" Button drücken. Beenden lässt sich dein erstes Programm, indem du, wie sonst auch, auf das "x" für schließen im Fenster klickst.[break][break]\r\nWenn wir jetzt möchten, dass was passiert, wenn man auf den Knopf auf deinem Formular drückt, dann müssen wir dies programmieren. Und genau das machen wir jetzt. [break]\r\nKlicke in der IDE auf deinen Button, so dass du seine Eigenschaften im Objektinspektor siehst. Dort gehst du auf das Register "Ereignisse" und suchst dort das Ereignis "OnClick".  Das ist das Ereignis, das ausgelöst wird, wenn jemand auf deinem Button klickt. Doppelclick auf "OnClick". Jetzt hat sich  das zum Formular gehörige Code-Fenster geöffnet und auch gleich die passende Procedure angelegt. Alles was du nun in diese Procedure zwischen "begin" und "end" schreibst, wird ausgeführt, wenn du auf den Knopf drückst. (Du kannst jederzeit zwischen Formular-Design und Formular-Code wechseln, indem du die Register "Code" und "Design" in der Mitte, ganz unten benutzt.) Jetzt schreiben wir aber erst einmal unsere erste eigene Zeile.[break]\r\nWir wollen, wenn jemand auf den Knopf drückt, dass im Textfeld "Hello World" erscheint. Die [big]Aktion[/big] wir also über das [big]Ereignis[/big] "OnClick" vom Button ausgelöst. Das ist super, das haben wir schon angelegt, Jetzt wollen wir darin auf das [big]Objekt[/big] "Edit1" (das ist unser Edit-Feld) zugreifen und dort die [big]Eigenschaft[/big] "Text" ändern. Diese Eigenschaft kann man wie folgt ansprechen Edit1.Text (Objekt.Eigenschaft). Um es auf einen neuen Wert zu setzen, müssen wir nur mit ":=" einen neuen Wert zuweisen. Jede Anweisung wird mit einem Semikolon beendet. Folgender Code muss also in der Code-Ansicht eingegeben werden.\r\n\r\n\r\n[code]\r\nprocedure TForm1.Button1Click(Sender: TObject); \r\nbegin\r\n  Edit1.Text := \'Hello World\'; //nur diese Zeile ergänzen\r\nend;\r\n[/code]\r\n\r\n Dann das ganze wieder ausführen  Jetzt sollte sich auf Knopfdruck der Text ändern. [break][break]\r\n\r\nGratulation, das ist das erste eigene Programm.[break] [break]\r\n\r\nDas das \'Hello World\' in Hochkommas steht ist sehr wichtig. So erkennt der Compiler das \'Hello World\' als Text und versucht nicht ein weiteres Objekt oder eine Variable zu deuten. Immer wenn wir Texte oder besser gesagt [big]Zeichenketten[/big] zuweisen oder vergleichen, benötigen wir dies Hochkommas.[break]\r\nDas, was nach dem "//" steht, wird vom Programm nicht ausgeführt. Es ist nur ein Kommentar des Programmierers.\r\n\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Ändere dein Projekt ab, indem du noch folgende Komponenten hinzufügst:\r\n    \r\n      [task]TLabel[/task]\r\n      [task]TMemo[/task]\r\n      [task]TButton[/task]\r\n      [task]TCheckbox[/task]\r\n      [task]TListbox[/task]\r\n      [task]TCombobox[/task]\r\n    \r\n  [/task]\r\n  [task]Sehe dir von allen Komponenten die Eigenschaften im Objektinspektor an und ändere einige ab. Beobachte was passiert und \r\n      schreibe die wichtigsten heraus.[/task]\r\n \r\n[/tasks]\r\n\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, dass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n', 0, 0, '', 0, 0, 1, ''),
	(58, 'cNjJiOWU2NDNiMGY:', 0, 1446468853, 5, 5, 1446468853, 3, 4, 'Die Welt der Objekte', '[headline]Kapitel 3 - Die Welt der Objekte[/headline] \r\n\r\nDas Prinzip der Objekte ist recht simpel und wird daher in fast allen Programmiersprachen aufgegriffen. So ist zum Beispiel jedes Edit-Feld ein Objekt. Es besitzt Eigenschaften oder auch [big]Attribut[/big] genannt (Größe, Farbe, Text, ...) und [big]Methoden[/big] (clear, undo, ...). Die Methoden sind quasi Aktionen, die man auf diesem Objekt ausführen kann. Man kann mehrere Objekte vom gleichen Typ erzeugen. So kann man zum Beispiel drei Edit-Felder: Edit1, Edit2 und Edit3 erzeugen. Diese haben alle die selben Methoden und die gleichen Eigenschaften, aber ggf. unterschiedliche [big]Werte[/big]. So kann Edit1.Text den Wert "Hallo" haben und Edit2.Text den Wert "Super" besitzen. [break]\r\nNehmen wir uns ein Beispiel aus dem Alltag: Das Mäppchen. Attribute sind zum Beispiel: Farbe, Breite, Höhe und Material. Diesen Attributen können dann auch Werte zugeteilt werden (rot, 12cm, 5cm, Leder). Bleiben nur noch die Methoden. Das ist aber auch nicht schwer: öffnen und schließen. [break][break]\r\n\r\nWer legt aber fest, welche Eigenschaften und Methoden so ein Objekt hat? Das macht die so genannte Klasse. Sie ist eine Art Vorlage. In ihr werden die Attribute festgelegt und die Methoden spezifiziert (und programmiert). So muss man für unser Edit1-Feld lediglich die Klasse TEdit [big]implementieren[/big] (anderes Wort für programmieren) und schon kann man diese Klasse ständig wiederbenutzen und tausende Edit-Felder erzeugen. [break]\r\nAnmerkung: Hier kommt schon ein sehr wichtiges Prinzip zum Tragen: Das Prinzip der Wiederverwendbarkeit. Wir werden später noch weiter darauf eingehen. [break][break]\r\n\r\nBei Delphi gibt es die Übereinkunft (aber keine feste Regel), dass man Klassennamen mit einem T beginnt. In anderen Sprachen, wie zum Beispiel Java, hat man sich darauf geenigt, dass man bei Klassen den Anfangsbuchstaben groß schreibt und bei Objekten, Attributen und Methoden immer mit einem kleinen Buchstaben beginnt. [break][break]\r\n\r\nJetzt kann man noch etwas besonderes machen. Man kann nicht nur [big]elementare Datentypen[/big] (siehe auch nächstes Kapitel) wie Texte oder Zahlen als Attribut verwenden, sondern auch weitere Objekte. Warum? Weil das manchmal ganz hilfreich und angenehm ist. Beispiel: Zieht euch mal eine TListBox auf euer Formular. Dieses Listbox-Element kann mehrere Einträge in der Liste besitzen. Diese Einträge sind gehören zum Objekt und müssen also irgendwie im Attribut stehen. Nun gut, dann könnte man ja die Attribute Eintrag1, Eintrag2, ... in der Klasse TListBox anlegen. Das ist aber nicht ganz so optimal, da wir so immer schon eine maximale Anzahl an Einträgen in der Listbox festlegen. Im Grunde bräuchten wir ein Objekt, dass mehrere Einträge Einträge verwaltet. Dieses Objekt wird dann als Attribut in der Listbox aufgeführt. Die Klasse, die mehrere (Text-)Einträge verwalten kann heißt "[big]TStrings[/big]". Diese Klasse hat Delphi uns netter Weise schon bereitgestellt. Die Listbox enthält also ein solches Objekt namens Items vom Typ TStrings. Ansprechen kann man daher die Listbox wie folgt:\r\n\r\n[code]\r\nprocedure TForm1.Button1Click(Sender: TObject); \r\nbegin\r\n  Listbox1.Items.Add(\'Hallo\');   // Das Listbox1-Objekt besitzt als Attribut ein weiteres Objekt namens Items\r\n                                 // von Idems wird hier die Methode Add() aufgerufen und der Parameter \'Hallo\'\r\n                                 // übergeben. Es wird der Eintrag \'Hallo\' in der Liste angehängt.\r\n  Listbox1.Items.Add(\'Ich\');     // weitere Einträge werden an die Liste angehängt\r\n  Listbox1.Items.Add(\'bin da\');  // ...\r\nend;\r\n[/code]\r\n\r\nTStrings hat auch weitere Methoden, zum Beispiel:[break]\r\n\r\n[code]\r\nprocedure TForm1.Button1Click(Sender: TObject); \r\nbegin\r\n  Listbox1.Items.Clear;	                       // löscht alle Einträge\r\n  Listbox1.Items.Add(\'Ich\');                   // fügt welche an\r\n  Listbox1.Items.Add(\'bin da\');                // fügt welche an\r\n  Edit1.Text := inttostr(Listbox1.Items.Count);// Liefert die Anzahl der Einträge zurück und gibt sie aus\r\n  Listbox1.Items.Insert(1,\'Dazwischen\');       // Fügt einen Eintrag zwischen anderen an Stelle 1 ein.\r\n  Listbox1.Items.Delete(1);                    // Löscht Eintrag an Stelle 1.\r\nend;\r\n[/code]\r\n\r\n\r\nDann gibt es da auch noch die Ereignisse. Fast jedes Objekt hat mögliche Ereignisse. Es sind meist mehr, als man denkt. Natürlich ist es ein Ereignis, wenn man auf einen Button klickt. Doch es gibt noch viele weiere Ereignisse. Zum Beispiel: Man geht mit der Maus nur über den Button (ohne zu drücken), man klickt runter (ohne loszulassen), man drückt eine Keyboard-Taste oder beim Drag and Drop vom bzw. auf den Button. Sie alle kann man über den Objektinspektor aufrufen.[break][break]\r\n\r\nVielleicht stellt sich der ein oder andere, ob es sich hierbei um die sogenannte [big]objektorientierte Programmierung (OOP)[/big] handelt. Nich wirklich. Zwar gibt es hier Objekte und auch schon Klassen und Methoden, aber eine richtige OOP setzt eine ganz andere Vorgehensweise des Programmierens vorraus. Wir programmieren zunächst [big]imperativ[/big] und werden erst später objektorientiert programmieren. Erst dann wird auch der Unterschied klar.\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Ihr habt sicherlich schon bemerkt, dass Delphi automatisch Vorschläge beim Schreiben bietet, wie es weiter gehen könnte. Diese Vorschläge sind sehr\r\n      hilfreich, da Delphi so alle möglichen Attribute und Methoden zu einem Objekt ausgibt. Schaue dir einmal diese Listen von TButton, TEdit, TListbox,\r\n      ... an und probiere einige Methoden aus, bzw. gebe einige Attibute aus.  [/task]\r\n  [task]Schreibe (auf Papier) fünf Objekte aus deiner Umwelt (nicht aus dem PC) auf und benenne die Klasse, Attribute, Methoden und Eigenschaften.       Vergleiche diese Ergebnisse mit den Ideen anderer Schülerinnen bzw. Schüler.[/task]\r\n \r\n[/tasks]\r\n\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, dass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(59, 'cZjEwMmQ1NmE2NDE:', 0, 1446468871, 5, 5, 1446472043, 3, 5, 'Variablen und Funktionen', '[headline]Kapitel 4 - Variablen und Funktionen[/headline] \nHin und wieder müssen wir Daten ablegen. Zum Beispiel lesen wir ein Textfeld über z.B. Edit1.Text aus und möchten uns seinen Inhalt zwischenspeichern. Dafür müssen wir zunächst einmal Speicherplatz besorgen. Das machen wir, indem wir uns eine [big]Variable[/big] anlegen. Dieses Anlegen nennt man auch [big]deklarieren[/big]. Das Deklarieren von Variablen kann man an vielen Stellen im Code machen, aber nicht jede ist auch wirklich dafür geeignet. Brauche ich eine Variable nur innerhalb meiner Procedure, dann sollte ich diese auch dort anlegen. Dies macht man zwischen der Procedure-Zeile und dem Begin mit dem [big]Schlüsselwort var[/big]. (Schlüsselwörter sind allgemein in einer Sprache reservierte Wörter, wie zum Beispiel: var, procedure, if, begin, end, ...). Hier ein Beispiel:[break] \n\n[code]\nprocedure TForm1.Button1Click(Sender: TObject); \n var user:string;                 //hier wird die Variable s deklariert\nbegin\n  Edit1.Text := \'Hello World\'; \nend;\n[/code]\n\n"var" besagt, dass nun eine Variable angelegt werden soll. [break]\n"user" ist der Name der Variable [break]\n"string" ist der Typ der Variable [break][break]\n\nEine Variable besitzt 3 wichtige Sachen: Einen [big]Namen[/big] (quasi die Beschriftung der Variable), einen [big]Typ[/big] (was darf ich reinlegen: Texte, Zahlen, ...) und einen [big]Wert[/big] (also den Text oder die Zahl den ich darin ablegen will). Der Variablenname darf keine Umlaute beinhalten und darf nur mit einem Buchstaben anfangen (dann aber auch Ziffern beinhalten). Delphi ist nicht casesensitiv, das heißt, dass UsEr die gleiche Variable bezeichnet wie zum Beispiel useR.[break][break]\n\nWelche Typen gibt es? Viele! Hier die für uns relevanten:\n\n    \n      [li][big]string[/big] - Hier kann man eine ganze Zeichenkette aus Buchstaben, Ziffern und Sonderzeichen ablegen[/li]\n      [li][big]integer[/big] - Hier kann man ganze Zahlen von -2147483648 bis 2147483647 hineinlegen[/li]\n      [li][big]real[/big] - Hier kann man Kommazahlen unterbringen[/li]\n      [li][big]char[/big] - Da passt genau ein Zeichen  (Buchstabe, Ziffer oder Sonderzeichen) hinein.[/li]\n      [li][big]boolean[/big] - Kann nur 2 Werte beinhalten: true oder false (wahr oder falsch)[/li]\n    \n\nMit Integer und Real kann man rechnen, ein String muss erst in einen solchen Typ umgewandelt werden, möchte man mathematische Operationen mit ihm durchführen. Für mathematische Operationen gibt es in Delphi folgende Operatoren: [big]+[/big] Plus, [big]-[/big] Minus, [big]*[/big] Mal, [big]div[/big] ganzzahlige Division, [big]/[/big] Division mit Dezimalzahlen, [big]mod[/big] Restoperator [break][break]\n\nBetrachten wir nochmals obiges Code-Beispiel. Hier legen wir eine Variable vom Typ string an. Wir können also darin eine Zeichenketten unterbringen. Der Name der Variable "user" verrät, dass wir darin wohl einen Usernamen ablegen wollen. Bisher machen wir aber noch gar nichts damit. Wir haben nur die Variable angelegt. Das wird sich aber im nächsten Beispiel ändern. [break]\n\n[code]\nprocedure TForm1.Button1Click(Sender: TObject); \n var user:string;                 //hier werden die Variablen user und pass deklariert\nbegin\n  user := Edit1.Text;             //hier wird der Inhalt des Textfeldes auf die Variable user gelegt.\nend;\n[/code]\n\nAchtung: das ":=" weißt immer der linken Variable den Wert der rechten zu. Nicht umgekehrt![break][break]\n\nJetzt haben wir auch endlich die Variable mit einem Wert befüllt. Wenn wir uns noch zwei weitere Textfelder Edit2 und Edit3 anlegen, dann können wir auch folgendes machen: [break]\n\n[code]\nprocedure TForm1.Button1Click(Sender: TObject); \n var user,pass:string;               \nbegin\n  user := Edit1.Text;             //hier wird der Inhalt des Textfeldes auf die Variable user gelegt.\n  pass := Edit2.Text;             //hier wird der Inhalt des Textfeldes auf die Variable pass gelegt.\n  Edit3.Text := user + pass;      //hier werden die Strings aneinandergehängt.  \nend;\n[/code]\n\nWenn man obiges Programm einmal ausprobiert, so bemerkt man, dass die Strings user und pass aneinander gehängt werden. Logisch! Zeichenketten kann man nicht addieren. Daher wird hier der "+"-Operator zum Aneinanderhängen ([big]Konkatenation[/big]) benutzt, selbst wenn man nur Zahlen in den Textfeldern eingibt. [break]\nMöchte man aber mit diesen Werten rechnen, so muss man diese zunächst umwandeln. Das geht mit dem Befehl [big]strtoint()[/big] (String To Integer), bzw. umgekehrt inttostr(). Hier ein Beispiel:\n\n[code]\nprocedure TForm1.Button1Click(Sender: TObject); \n var zahl1,zahl2:integer;             //hier wird die Variable zahl1 und zahl2 als ganze Zahlen deklariert\nbegin\n  zahl1 := strtoint(Edit1.Text); //hier wird der Inhalt des Textfeldes zunächst zur Zahl \n                                 //umgewandelt und dann auf die Variable zahl1 gelegt.\n  zahl2 := strtoint(Edit2.Text); //hier wird der Inhalt des Textfeldes zunächst zur Zahl \n                                 //umgewandelt und dann auf die Variable zahl2 gelegt.\n  Edit3.Text := inttostr(zahl1 + zahl2); //hier werden die Zahlen zunächst addiert und \n                                         //dann in einen String umgewandelt.  \n  Edit1.Text := floattostr(14 div 5);    // ergibt 2, da ganzzahlige Division (Grundschule)\n  Edit1.Text := floattostr(14 mod 5);    // ergibt 4, da 14:5= 2 Rest 4 (Grundschule)\n  Edit1.Text := floattostr(14 / 5);      // ergibt 2,8\n  Edit1.Text := floattostr(14 * 5);      // ergibt 70\nend;\n[/code]\n\nDie ersten Zeilen sind klar. Man darf aber auch nicht zum Schluss vergessen, dass Edit3.Text auch vom Typ String ist und daher auch nur Zeichenketten übergeben bekommen darf. Daher muss man nach dem Addieren die Zahlen wieder mit inttostr() zurück in einen String umwandeln. [break][break]\n\nDie Befehle inttostr() bzw. strtoint() gehören zu den so genannten [big]Funktionen[/big]. Fast alle Funktionen haben mindestens einen [big]Parameter[/big], den man an die Funktion innerhalb der Klammern übergibt. Dann berechnen Funktionen irgendetwas und liefern ein Ergebnis zurück. Auf Funktionen kann man nur lesend zugreifen. Hier ein paar Beispiele zum Verdeutlichen.\n\n[code]\n  zahl1 := strtoint(Edit1.Text); //strtoint() erwartet einen Parameter und das muss ein string sein \n                                 //und liefert einen Wert (integer) zurück\n  strtoint(Edit2.Text) := zahl2; //Das macht keinen Sinn und ist nicht erlaubt, da man versucht \n                                 //auf eine Funktion zu schreiben.\n  Edit3.Text := inttostr(12345); //Auch OK, man darf auch statt Variablen direkt Zahlen bzw. Texte übergeben.\n  Edit3.Text := inttostr(strtoint(Edit2.Text)+strtoint(Edit1.Text)); //Auch OK, erst werden die Texte umgewandelt, \n                                                                     //dann addiert, dann wieder zurückgewandelt\n  Edit3.Text := \'Hallo \'+inttostr(12)+\' !\'; //Auch OK, hängt Zeichenketten aneinander\n[/code]\n\nWenn jemand keine Zahl eingibt und man dann den String in eine Zahl umwandeln möchte, so kommt es zu einer unschönen Fehlermeldung. Wie man solche Fehler abfängt werdet ihr später erfahren. [break][break]\n\nWeitere Funktionen sind zum Beispiel [break]\n[big]random(X)[/big] - Zufallszahl [break]\n[big]round(X)[/big] - Runden [break]\n[big]sqrt(X)[/big] - Wurzel [break]\n[big]floattostr(X)[/big] - wandelt einen Real in einen String um[break][break]\n\nAchtung, die Funktion sqrt erwartet einen integer oder real als Parameter und liefert einen real zurück. Möchte man einen real in einen String umwandeln, um diesen auszugeben, bedarf es der Funktion floattostr (bzw. strtofloat)\nRound nimmt ebenfalls einen float entgegen und liefert einen integer zurück.\n\n[code]\nprocedure TForm1.Button1Click(Sender: TObject);\nbegin\n  Randomize;                           // Zufallsgenerator wird initiert, danach klappt auch die Funktion random()\n  Edit1.Text := inttostr(random (8));  // Erzeuge eine Zahl zwischen 0..7 (das sind 8 Möglichkeiten, daher die 8)\n  Edit2.Text := floattostr(sqrt(10));  // Ziehe die Wurzel aus 10 und wandel das Ergebnis in einen String um.\n  Edit3.Text := floattostr(sqrt(strtoint(Edit1.Text)));  // Wurzel aus Edit1 in Edit3 schreiben.\n  Edit4.Text := inttostr(round(strtofloat(Edit1.Text)));  // Rundet Textfeld1 und gibt es in Edit4 aus.\nend;\n[/code]\n\n[tasks]\nAufgaben: [break]\n \n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\n  [task]Experementiere mit allen Variablentypen ein wenig. Deklariere sie, setze sie, rechne mit ihnen, füge die zusammen und gebe sie aus. Erst wenn du       einen sehr sicheren Umgang mit Variablen hast, solltest du weitermachen.[/task]\n  [task]Schreibe ein Programm, das 3 Textfelder besitzt und jeweils ein "+", "-", "*", ":" und ein "Wurzel"-Button besitzt. In die ersten beiden Textfelder       sollen die Eingabe erfolgen, je nach Knopfdruck, soll dann das Ergebnis im Textfeld3 ausgegeben werden. Die Wurzel arbeitet mit dem Textfeld1 [/task]\n  [task]Versuche dein Programm optisch ein wenig aufzuwerten und setze das Textfeld3 auf ReadOnly, so dass der Benutzer nicht darein scheiben kann.[/task]\n  [task]Gebe das Taschenrechner-Programm ab, um in das nächste Level zu gelangen.[/task]\n  [task](opt) Schaffst du es einen Taschenrechner zu basteln, der mit nur einem Textfeld auskommt? (also wie unserer Taschenrechner in der Schule)?[/task]\n  [task](opt) Du kannst dann auch noch die Knöpfe von 0..9 basteln und so einem echten Taschenrechner noch näher kommen.[/task]\n \n[/tasks]\n', 0, 0, '', 0, 0, 1, ''),
	(60, 'cODRhZTdjOGQ5MWI:', 0, 1446468888, 5, 5, 1446468888, 3, 6, 'String-Operationen', '[headline]Kapitel 5 - String-Operationen[/headline] \r\nIn diesem Kapitel sollst du ein paar Funktionen kennenlernen, die dir helfen mit Strings umzugehen. Mit Strings, also mit Zeichenketten, kann man nämlich eine ganze Menge machen. Man kann sie durchsuchen, ob irgendwo eine bestimmte Zeichenfolge vorkommt. Man kann aber auch in Strings Teilstrings einfügen oder Stellen löschen. Hier die wichtigsten Befehle:[break] \r\n\r\n\r\n[li][big]pos[/big] (SuchString, String in dem gesucht wird) Liefert die Position des ersten Vorkommens des Suchstrings zurück[/li]\r\n[li][big]copy[/big] (welcher String, Startposition, Länge) Liefert einen Teilstring zurück - Der Ausgangsstring wird dabei NICHT geändert! [/li]\r\n[li][big]delete[/big] (welcher String, Startposition, Länge) Scheiden ein Stück aus den String raus. Dabei wird der Ausgangsstring geändert![/li]\r\n[li][big]length[/big] (welcher String) Liefert die Länge des Strings zurück[/li]\r\n[li]Stringname[big][Position][/big] Liefert das Zeichen an der entsprechenden Position zurück[/li]\r\n[li][big]ord[/big](ein Zeichen) Liefert den Ascii-Code des übergebenen Zeichens zurück[/li]\r\n[li][big]chr[/big](AsciiCodeZahl) Liefert das zum AsciiCode gehörige Zeichen zurück[/li]\r\n\r\n[break]\r\nHier nochmals alles im praktischen Beispiel: [break]\r\n\r\n[code]\r\n var s : string;\r\nbegin\r\n s:= \'Ich kann das nicht!\';\r\n showmessage (inttostr(pos (\'da\',s)));  // liefert die 10 zurück und gibt diese aus\r\n showmessage (copy (s,5,8));            // liefert \'kann das\' zurück und gibt es aus\r\n delete (s,13,6);                       // scheidet das \' nicht\' aus s raus (mit Leerzeichen)\r\n showmessage (s);                       // zeigt den String s nun verändert an\r\n showmessage (inttostr(length(s)));     // liefert die Länge (13) von s zurück und gibt diese aus\r\n showmessage (s[3]);                    // liefert den 3. Buchstaben (h) von s zurück und gibt diese aus\r\n showmessage (inttostr(ord(s[3])));     // Liefert den Ascii-Code vom 3. Buchst. \'h\' zurück und gibt es aus\r\n showmessage (chr(65));                 // Liefert das Zeichen (A) zum AsciiCode 65 zurück und gibt es aus\r\nend;\r\n[/code][break]\r\n\r\nAlles klar? Sonst einfach mal nach den Begriffen googlen, also z.B. "Delphi copy" eingeben. Dort gibt es weitere Erklärungen und Beispiele\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Schreibe ein Delphi-Programm und benutze dort alle oben erklärten Befehle.[/task]\r\n  [task]Suche im Internet nach mindestens einem weiteren Delphi-Befehl, der mit Strings arbeitet.[/task]\r\n  [task]Baue den neuen Befehl in dein Programm ein, in welchem du alle anderen String-Befehle eingearbeitet hast und gebe diese Aufgabe nun ab.[/task]\r\n \r\n[/tasks]\r\n\r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(61, 'cYzc1MzAzOWM0MjI:', 0, 1446468904, 5, 5, 1446468904, 3, 7, 'Lokal / Global', '[headline]Kapitel 6 - Lokal / Global[/headline] \r\nBei den Variablen muss man nicht nur darauf achten, dass man ihnen einen geschickten Namen gibt, ihnen den richtigen Typ zuweist \r\nund dann auch noch den korrekten Wert zuordnet - man muss auch darauf achten, ob die Variable eine [big]lokale[/big] oder [big]globale[/big]\r\nVariable sein soll. In der Regel sind unsere Variablen lokal definiert. Das sind Variablen, die in Prozeduren oder \r\nFunktionen definiert werden oder Parameter von diesen sind. \r\n\r\n[code]\r\nprocedure TForm1.Button1Click(Sender: TObject); // Sender ist eine lokale Variable, da Sender ein Parameter \r\n                                                // der Prozedur ist\r\n var s: string;                                 // Auch s und i werden innerhalb der Prozedur definiert und\r\n     i: integer;                                // sind daher lokal.\r\nbegin\r\n ...\r\nend;\r\n[/code][break]\r\n\r\nLokale Variablen gelten nur innerhalb ihrer Funktion bzw. Prozedur. Wird diese mit "end;" beendet, so erlischt auch die\r\nVariable und die gesamt Variable ist außerhalb der Funktion / Prozedur nicht bekannt.\r\n\r\n[code]\r\n\r\nvar text3 : string;                             // Legt eine globale Variable an. Die gehört zum Hauptprogramm\r\n                                                // und nicht zu irgendeiner Prozedur / Funktion\r\n\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\n var text1: string;                             // Legt die lokale text1 an, sie ist nur innerhalb der Prozedur\r\n                                                // bekannt.\r\nbegin\r\n text1:=\'Hallo1\';                               // Setzt die lokale Variable auf Hallo1\r\n text2:=\'Hallo2\';                               // FEHLER, text2 ist nicht bekannt. Programm wird nicht compiliert\r\n text3:=\'Hallo3\';                               // Setzt die globale Variable auf Hallo3\r\nend;\r\n\r\nprocedure TForm1.Button2Click(Sender: TObject);\r\n var text2: string;                             // Lokale Variable text2\r\nbegin\r\n text1:=\'Hallo1\';                               // FEHLER, text1 ist nicht bekannt. Programm wird nicht compiliert\r\n text2:=\'Hallo2\';                               // Setzt die lokale Variable auf Hallo2\r\n text3:=\'Hallo3\';                               // Setzt die globale Variable auf Hallo3\r\nend;\r\n\r\n[/code][break]\r\n\r\nMan sollte mit möglichst wenig globalen Variablen auskommen. Diese gelten im ganzen Programm  und machen das Programm \r\nunübersichtlich. Sie lassen sich meistens nicht ganz vermeiden und sind recht bequem aber in aller Regel unsauber. \r\nWenn man schon globale Variablen benutzt, dann sollte man diese nicht i oder s nennen, sondern diesen  möglichst lange eindeutige Variblennamen geben. \r\nZum Beispiel: DerzeitAktiverUser oder z.B. UserDataEntryCount.\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Experimentiere ein wenig mit globalen / lokalen Variablen, bis du einen sicheren Umgang mit diesen hast.[/task]\r\n \r\n[/tasks]\r\n\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, \r\ndass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n\r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(62, 'cODFkYjdlZDBhMGE:', 0, 1446468920, 5, 5, 1446468920, 3, 8, 'Verzweigungen', '[headline]Kapitel 7 - Verzweigungen[/headline] \r\nWie schon in der Enleitung geschildert, benötigen wir so genannte Kontrollstrukturen, die es erlauben, den Programmfluss zu beeinflussen. In diesen Kapitel werden wir die sogenannte Verzeigung kennenlernen. Im Grunde hanedlt es sich dabei um eine ganz einfache Sache: [break][break]\r\n\r\nWenn (Bedingung) Dann (Anweisung oder Block mit Anweisungen) Sonst (Anweisung oder Block mit Anweisungen)[break][break]\r\n\r\nDie [big]Bedingung[/big] kann eine Überprüfung von Feldern oder Variablen sein und darf auch durch "und" bzw "oder" aus mehreren Bedingungen verknüpft werden. Möchte man mehr als eine Anweisung folgend lassen, wenn die Bedigung erfült ist, so muss man einen [big] Block [/big] mit "begin" und "end" erzeugen. Den Sonst-Teil kann man bei jeder Verzweigung benutzen, muss es aber nicht. Da Delphi an die englische Sprache angelegt ist, benutzen wir [big]if[/big] (wenn), [big]then[/big] (dann) und [big]else[/big] (sonst). Wir sprechen von einer Verzweigung oder auch einer [big]IF-Anweisung[/big].[break][break]\r\n\r\nHier ein paar Beispiele ohne else und mit einfacher Bedigung:[break]\r\n\r\n[code]\r\nif (i=1) then            // Wenn die Variable i den Wert 1 hat, dann ...\r\n  edit1.text = \'Juhu\';   // ... schreibe in Edit1 "Juhu" rein. Der Zeilenumbruch nach den "then" ist nicht \r\n                         // unbedingt nötig, gehört aber zum guten Stil\r\n\r\nif (user=\'Hans\') then    // Wenn die Variable user den Wert \'Hans\' hat, dann ...\r\nbedin                    // (beginne neuen Block, alles im Block um zwei Leerzeichen einrücken)\r\n  edit1.text = \'Hallo\';  // ... schreibe in Edit1 "Hallo" rein.\r\n  edit2.text = \'Hans\';   // ... schreibe in Edit2 "Hans" rein. \r\nend;                     // (Ende des Blocks, gehört genau unter das begin)\r\n\r\n[/code]\r\n[break]\r\n\r\nAuch wenn es in Delphi nicht nötig ist, sollte man Bedingungen immer klammern. Ganz wichtig ist das richtige Einrücken! Dieses sollte man immer direkt beim schreiben machen. Nachträgliches Einrücken (für den Lehrer) ist unvorteilhaft. Gerade bei vielen Blöcken, die auch ineinander geschachtelt werden können, verliert man sonst schnell den Überblick. [break][break]\r\n\r\nHier ein paar Beispiele mit else und mit einfacher Bedigung:[break]\r\n\r\n[code]\r\nif (i  10) then         // Wenn die Variable i größer als 10 ist, dann ...\r\n  edit1.text = \'Juhu\'    // ... schreibe in Edit1 "Juhu" rein. (KEIN Semikolon - der Befehl ja weiter!)\r\nelse                     // sonst (i ist also kleiner oder gleich 10)\r\n  edit1.text = \'Ohje\';   // ... schreibe in Edit1 "Ohje" rein. (erst jetzt ein Semikolon - Befehl ist zuende)\r\n\r\nif (user  \'Hans\') then         // Wenn die Variable user ungleich den Wert \'Hans\' hat, dann ...\r\nbedin                            // (beginne neuen Block, alles im Block um 2 Leerzeichen einrücken)\r\n  edit1.text = \'Hallo du bist\';  // ... schreibe in Edit1 rein.\r\n  edit2.text = \'nicht Hans\';     // ... schreibe in Edit2 rein. \r\nend else                         // (Ende des Blocks, gehört genau unter das begin, KEIN Semikolon!)\r\nbegin                            // (Anfang des else-Blocks)\r\n  edit1.text = \'Hallo du bist\';  // ... schreibe in Edit1 rein.\r\n  edit2.text = \'der Hans!!\';     // ... schreibe in Edit2 rein. \r\nend;                             // Ende der gesamten Anweisung, dager Semikolon\r\n\r\n[/code]\r\n[break]\r\nIhr habt gerade die wichtigen [big]Vergleichsoperatoren[/big] kennengelernt: [break]\r\n\r\n [li]    größer[/li]\r\n [li]    kleiner[/li]\r\n [li]   größer gleich[/li]\r\n [li]   kleiner gleich[/li]\r\n [li]    gleich[/li]\r\n [li]   ungleich[/li]\r\n \r\n \r\nEs fehlen jetzt nur noch die [big]boolschen Operatoren[/big]. Keine Angst, das klingt komplizierter als es ist. Ein Boolean ist ein Wert, der nur wahr oder falsch annehmen kann. Jede Bedigung kann ebenfalls nur wahr oder falsch sein. Operatoren zwischen einzelnen Bedingungen sind daher boolsche Operatoren. Wir benutzen drei Stück: Und, Oder und das Nicht. In Delphi: [big]"and", "or", "not"[/big]. Die Benutzung ist recht intuitiv:[break]\r\n\r\n[code]\r\n\r\nif ((user = \'Hans\') and (pass=\'Küche\')) then ...  // Nur, wenn user den Wert \'Hans\' und pass den Wert \'Küche\'\r\n                                                  // besitzt, geht es in den Dann-Teil\r\n// Bitte die Klammerung beachten, jede Bedigung für sich und alles zusammen dann nocheinmal klammern.\r\n\r\nif ((user = \'Hans\') or (pass=\'Küche\')) then ...   // Hier muss entweder der user oder pass stimmen.\r\n\r\nif ((2=i) and (i=10)) then ...      // Nur i zwischen 2 und 10 liegt geht es in den Dann-Teil\r\n\r\nif ((i=3) or (i4) or (i3)) then ... // Angenommen i ist ein Integer (ganze Zahl), so ist diese Bedingung gleich mit\r\nif (i4) then ...                    // dieser hier.\r\n\r\n\r\nif (not(i5)) then ...  // Wenn nicht (i5) erfüllt ist, also 5, dann ...\r\n[/code]\r\n[break]\r\n\r\nLetztlich möchten wir noch "and" und "or" kombinieren. Da müssen wir aufpassen. Hier ein Beispiel aus der deutschen Sprache, welches uns das Problem veranschaulicht. Vor dir stehen vier Becher (rot, grün, gelb und blau). Du findest einen Zettel: "Der rote und der grüne oder der gelbe und der blau Becher sind vergiftet. Wie viele Becher sind denn nun vergiftet. Zwei? Oder doch drei? Das hängt von der Klammerung ab: [break]\r\n(Der rote und der grüne) oder (der gelbe und der blau Becher)   // hier sind entweder die beiden Becher (rot und grün) vergiftet oder die anderen beiden Becher (gelb und blau).[break]\r\n(Der rote) und (der grüne oder der gelbe) und (der blau Becher) // hier sind auf jeden Fall rot und blau vergiftet. Zudem noch ein dritter Becher, nämlich grün oder gelb.[break][break]\r\n\r\n[code]\r\n\r\nif ( ((user = \'Hans\') and (pass=\'Küche\')) or          // Hier kann entweder der user \'Hans\' mit \'Küche\' \r\n     ((user = \'Timy\') and (pass=\'Mutti\')) ) then ...  // oder \'Timmy\' mit \'Mutti\' einloggen. \r\n                                                      // Gerade hier ist saubere Klammerung wichtig\r\n\r\n\r\nif (( ( x = \'Hans\') and (y=\'Küche\') ) or ((x = \'Timy\') and (y=\'Mutti\') )) then ...  \r\n    // Syntaktisch völlig OK, aber für den Programmierer kaum noch zu verstehen, \r\n    // daher gute Variablennamen, gut klammern und einrücken sowie gut kommentieren!\r\n\r\n[/code]\r\n[break]\r\n\r\nWie wir sehen können wir diesen Uneindeutigkeiten mit der richtigen Klammerung vorbeugen.[break][break]\r\n\r\nBetrachten wir uns noch die Sache mit den Blöcken. Diese haben in jeder Programmiersprachen ein hohe Relevanz.\r\n\r\n[code]\r\n\r\nif (i=10) then\r\nbegin\r\n                         // Hier geht der Rechner nur rein, wenn i den Wert 10 hat\r\n  if (y=3) then\r\n  begin\r\n    edit1.text=\'bla\';    // Hier muss zuvor i=10 sein und nun auch noch y=3 sein\r\n  end else\r\n  begin\r\n    edit1.text=\'bli\';    // Hier muss zuvor i=10 sein und y darf nicht 3 sein\r\n  end;\r\n\r\nend;\r\n[/code]\r\n[break]\r\n\r\nNach diesem Schema kann man nun (fast) beliebig viele Blöcke ineinander setzen. Nach jedem begin muss man in der nächsten Zeile um zwei Leerzeichen einrücken.\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Schreibe in deutscher Sprache, wann die folgenden Bedingungen erfüllt sind. Achte auf sprachliche Eindeutigkeiten. Gehe davon aus, dass a,b vom Typ integer, s vom Typ string, x,y vom Typ real sind. \r\n  \r\n    [task]if ( ((a2) or (b3)) and (a+b=10) ) then ... [/task]\r\n    [task]if ( (x=3) and (y=x-2) and (y1) ) then ... [/task]\r\n    [task]if ( ((x=0) or (x\r\n    [task]if ( (s=\'Yes\') and ((x=1.5) or (i=23)) ) then ... [/task]\r\n    [task]if ( (s=s) and (x=x) and (i=23) ) then ... [/task]\r\n  \r\n  [/task]\r\n  [task]Manche if-Anweisungen aus Aufgabe 2 kann man auch vereinfachen. Vereinfach diese und schreibe sie in deinen Ordner.[/task]\r\n  [task]Im AnAlle-Verzeichnis liegt die Login.jpg. Ziehe dir ein [big]TImage[/big] auf dein Formular und öffne über das Attribut "Picture" Login.jpg. Bastel so den Windowslogin unserer Rechner nach. Das Programm soll erst mit der Eingabe von Benutzer: "David" mit dem Passwort "ET" beenden. Der Befehl zum Beenden ist halt(0); [/task]\r\n  [task]Ändere deine Aufgabe 4 so ab, dass sie nun entweder den User \'David\' mit \'ET\' oder aber den User \'Tom\' mit dem Passwort \'Jadda\' akzeptiert.[/task]\r\n  [task](opt) Phishing ist eine (böse) Methode, durch Vorspielen einer entsprechenden Umgebung, Passwörter zu erlangen. Wenn du deinen Desktop leer räumst und einen blauen Windows-Hintergrund erzeugst, so kommt einen das Login richitg realistisch vor. Nun musst du lediglich die Eingabe in einer Datei speichern. Schaue dir dafür zum Beispiel folgende Seite an:  TextFile  [/task]\r\n \r\n Für das nächste Level Aufgabe 5 abgeben.\r\n\r\n[/tasks]\r\n', 0, 0, '', 0, 0, 1, ''),
	(63, 'cNDk3ZjQ0MzBmMjY:', 0, 1446468954, 5, 5, 1446468954, 3, 9, 'Sauberer Code', '[headline]Kapitel 8 - Sauberer Code[/headline] \r\nEs gibt viele Sprachen und in jeder Sprache muss man sauber programmieren.[break][break]\r\n\r\nWarum?[break]\r\nNun, damit man selber, aber auch andere sich in deinen Code zurecht finden. Programme werden mit der Zeit umfangreicher und damit schnell unüberischtlich. Wenn man einen sauberen Code schreibt dann behält man nicht nur die Übersicht, sondern hat von vornherein so programmiert, dass man sein Programm gute um weitere Funktionen erweitern kann. (Das will man fast immer). Zudem kann es passieren, dass man in ein Programm reinsieht, das man vor Jahren einmal geschrieben hat. Glücklich wer dieses vorher sauber kommentiert hat![break][break]\r\n\r\nJede Sprache?[break]\r\nJa, jede Programmiersprache muss sauber geschrieben werden. Aber Vorsicht: Unterschiedliche Sprachen kommen aus den unterschiedlichsten Bereichen und sind historisch gewachsen. Delphi ist quasi die Windowsversion von Pascal und viele Sachen sind von Pascal abgeleitet worden. Ein guter Programmierstil in Delphi muss nicht zwangsläufig auch ein guter in Java, PHP oder Javascipt sein. Solltet ihr also mal auf eine andere Sprache umsteigen, so müsst ihr hier und da auch euren Stil ändern. \r\n\r\nWie?[break]\r\nDie wichtigsten Regeln sind:[break]\r\n\r\n[li]Units (Formulare) gute Namen geben[/li]\r\n[li]Variablen gute Namen geben (nur in Schleifen darf man ein \'i\' als Variablennamen nutzen, sonst immer nur längere Namen)[/li]\r\n[li]Methoden (Prozeduren und Funktionen) benötigen einen guten Namen[/li]\r\n[li]Sauberes einrücken, damit man schnell sieht, was im und was außerhalb eines Blockes liegt[/li]\r\n[li]Sauberes Kommentieren. Dabei sollte man die [big]Semantik[/big] und nicht die [big]Syntax[/big] kommentieren.*[/li]\r\n[li]Man muss nicht jede Zeile kommentieren. Aber immer dort, wo nicht sofort klar ist, was du da machst, gehört ein Kommentar hin.[/li]\r\n[li]Ebenso solltest du vor jeder Methode (Procedure bz. Funktion) einen Kommentar schreiben, was diese macht.[/li]\r\n\r\n* Die Syntax ist quasie die Rechtschreibung und die Grammatik. Wenn diese nicht korrekt ist, so wird das Programm erst gar nicht starten. Die Semantik ist wie im deutschen der Ausdruck. Sie kann nicht durch einen Computer überprüft werden. Wenn dein Programm syntaktisch korrekt ist, heißt es noch lange nicht, dass es auch so läuft, wie du willst. Semmantisches Kommentieren bedeutet, dass man angibt, was du mit dieser Anweisung erreichen möchtest und nicht, was der Computer an dieser Stelle macht.[break]\r\n\r\n[code]\r\n// FALSCH, hier wird die Syntax kommentiert, das kann man auch an der Anweisung direkt ablesen\r\nif (u=\'Tim\') then  // Wenn u \'Tim\' ist, dann \r\n  rein;            // rufe die Procedure rein auf\r\n\r\n// Richtig, hier wird die Semantik kommentiert, zudem sind die Variablennamen besser\r\nif (username=\'Tim\') then  // Vergleiche auf richtigen Username\r\n  StartMainProgram;       // Starten des Hauptprogramms\r\n\r\n\r\n[/code]\r\n[break]\r\n\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir den Unterschied zwischen Syntax und Semantik in deinen eigenen Worten.[/task]\r\n  [task]Gehe auf folgende Seite:  hier und überfliege mal den Delphi Styleguide. Du kennst noch nicht alle Elemente, daher werden dir auch nicht alle Sachen etwas sagen, aber du weißt jetzt, wo man was nachschlagen kann, wenn du nicht weißt, wie man das Eine oder Andere sauber angibt.[/task]\r\n  [task]Notiere dir die wichtigsten Regeln für einen sauberen Code in deinen Ordner[/task]\r\n \r\n[/tasks]\r\n\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, dass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(64, 'cNWE5MTRjNmMxYjM:', 0, 1446468976, 5, 5, 1446468976, 3, 10, 'Das Flussdiagramm', '[headline]Kapitel 9 - Das Flussdiagramm[/headline] \r\n\r\n\r\nManchmal ist es wünschenswert einen Programmablauf anders darzustellen als mit einer Programmiersprache. Man wünscht sich eine Visualisierung von Abläufen, die unabhängig von der Sprache und möglichst intuitiv zu verstehen ist. Dies bietet das sogenannte [big]Flussdiagramm[/big]. Hier werden semantische Anweisungen in kleine Rechtecke geschrieben und diese werden dann mit Pfeilen verbunden. Die Anweisungen an sich in den Kästchen müssen dabei nicht in Delphi-Syntax geschrieben werden. Man kann sogar umgangssprachliche Stichwörter hineinschreiben. Wichtig ist, dass das Diagramm den Programmablauf verdeutlicht. [break] [break]\r\n\r\nwarum?[break]\r\nEin Flussdaigramm kann man zum Beispiel als Planungsgrundlage für ein Programm sehen. Man kann so ein Programm zunächst recht grob entwerfen und dann die einzelnen Anwesiungen immer detailierter im Flussdiagramm ausarbeiten. Erst dann beginnt man mit der eigentlichen Implementierung. Ein weiterer Einsatzbereich ist die Arbeit im Team. Ein Programm zu durchschauen dauert in aller Regel ziemlich lange. Hinzu kommt, dass nicht jeder im Team die benutzte Programmiersprache kann. Die "universelle Sprache" des Flussdiagramms kann daher besser bei Programmierprojekten im Team eingesetzt werden. Sie ist schnell zu überblicken und jeder versteht sofort, was das Programm machen soll. Als letzte weitere Möglichkeit für ein Flussdiagramm möchte ich an dieser Stelle noch die Verdeutlichung von Programmen, Algorithmen und allgemeinen Vorgängen angeben. Viele Vorgänge sind mittlerweile als Flussdiagramm hinterlegt (Versetzungsordnung) und wenn jemand ein Programm geschrieben hat und dieses einer Gruppe erläutern soll, so kann er dies mit Hilfe eines Flussdiagramms sehr sauber darstellen.\r\n\r\n\r\nHier ein Beispiel:[break]\r\n[break][break]\r\n\r\nIm Grunde sollte der Ablauf sofort klar sein, lediglich die unterschiedlichen Symbole bedürfen einer Erklärung:[break]\r\n[big]Oval[/big]: Start bzw Stop[break]\r\n[big]Pfeil[/big]: Verbinung zum nächsten Element[break]\r\n[big]Rechteck[/big]: Operation[break]\r\n[big]Rechteck mit doppelten, vertikalen Linien[/big]: Unterprogramm aufrufen[break]\r\n[big]Raute[/big]: Verzweigung[break]\r\n[big]Parallelogramm[/big]: Ein- und Ausgabe [break][break]\r\n\r\nFlussdiagramme in Wikipedia [break][break]\r\n\r\nGerade hier kann man besonders gut sehen, warum die if-Anweisung eine Verzweigung ist. An dieser Stelle gehen zwei ausgehende Pfeile von der Raute ab. [break]\r\nDen einen oder anderen ist sicherlich schon aufgefallen, dass das obige Diagramm noch nicht so ganz richtig ist. Denn in aller Regel kann man 3 Mal einen PIN-Code falsch eingeben, bis dieser nicht mehr akzeptiert wird. Diesen Fall werden wir im nächstem Kapitel betrachten.\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Erstelle (auf Papier) ein Flussdiagramm. Es soll eine möglichst lustige und zugleich auch ein wenig komplexe Anleitung zum Spicken sein. Zeige       diese deinen Lehrer vor, er setzt dich dann ins nächste Level.[/task]\r\n  [task]Suche im Netz oder in der Literatur nach Beispielen für Flussdiagramme außerhalb der Informatik. [/task]\r\n \r\n[/tasks]\r\n\r\n\r\n\r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(65, 'cYTM2MjNmNDNmNTg:', 0, 1446468997, 5, 5, 1446468997, 3, 11, 'Die Schleifen', '[headline]Kapitel 10 - Die Schleifen[/headline] \r\n\r\nNeben den Verzweigungen gibt es auch noch die Schleifen, die zu den Kontrollstrukturen gehören. Auch diese sind im Grunde recht intuitiv zu begreifen. Die Funktionsweise einer Schleife haben wir schon oben in der Einleitung kennengelernt.[break]\r\n\r\n \r\n [li] 1. Dein Zimmer aufräumen [/li]\r\n [li] 2. Deine Hausaufgaben machen [/li]\r\n [li] 3. Mit Charlie gassigehen [/li]\r\n [li] 4. Lerne deine Vokabeln [/li]\r\n [li] 5. Überprüfe, ob du wirklich alle Vokabeln kannst, sonst mache weiter bei Punkt 4[/li]\r\n\r\n\r\nHier springt man aus Zeile 5 wieder zu Zeile 4, sollte man seine Vokalben nicht gelernt haben. Ein weiteres Beispiel wäre, wenn man den folgenden Text ausgeben möchte: [break]\r\n\r\nDas ist die 1. Zeile[break]\r\nDas ist die 2. Zeile[break]\r\nDas ist die 3. Zeile[break]\r\n...[break]\r\nDas ist die 100. Zeile[break][break]\r\n\r\nDiese einhundert Zeilen kann man entweder alle einzeln im Programmcode angeben oder (was auch schon jeder Programmieranfänger merken sollte) mit Hilfe einer Schleife lösen. Die Idee der Schleife ist dann von der Art: [break][break]\r\n\r\nWiederhole folgendes 100 mal [break]\r\nbegin [break]\r\nend; [break][break]\r\n\r\nAlles was im begin-end-Block steht wird dann 100mal wiederholt. Da sich das Programm irgendwo merken muss, beim wie vielten Durchlauf es ist, benötigen wir eine Variable. Bei zählenden Schleifen hat sich der Variablenname i durchgesetzt. [break]\r\nFür das folgende Beispiel muss man auf seinem Formular ein sogenanntes Memofeld anlegen. Dies ist ein größeres Textfeld, welches mehrer Zeilen enthalten kann. Hier also jetzt die so genannte [big]for-Schleife[/big] in Delphicode:[break]\r\n\r\n\r\n[code]\r\nfor i := 1 to 100 do                                         // Schleife mit Variable i zählt von 1 bis 100\r\nbegin                                                        // Dieser Block wird wiederholt\r\n  memo1.Lines.add(\'Das ist die \' + inttostr(i) + \'. Zeile\'); // Füge im Memofeld eine Zeile an. \r\nend;                                                         // inttostr nicht vergessen, da man erst die \r\n                                                             // integer-Variable i in einen String umwandeln muss\r\n\r\n[/code]\r\n[break]\r\nAnmerkung: Memo-Komponente ist bekannt aus Kapitel 2 und das Verknüpfen von Zeichenketten mit inttostr() aus Kapitel 4. Damit das Programm läuft muss vorher noch die Variable i als integer deklariert werden. Der Aufruf der Schleife kann zum Beispiel in einem OnClick-Ereignis eines Buttons stehen. [break][break]\r\n\r\nEs gibt aber noch ganz andere Schleifen. Sie haben alle aber 2 Sachen gemeinsam. [break]\r\n1. Ein Codeteil der Wiederholt werden soll.[break]\r\n2. Eine Abbruchbedingung, wann die Schleife beendet werden soll. Bzw. eine Wiederholungsbedingung, wie lange die Schleife ausgeführt werden soll.[break]\r\n[break]\r\nHier ein größeres Beispiel mit der [big]while-Schleife[/big]. Man muss zuvor einen Button und zwei Textfelder angelegt haben.[break]\r\n\r\n[code]\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\n  var i, zahl :integer;\r\n      isPrim  :boolean;         // wird auf false gesetzt, wenn Teiler gefunden\r\nbegin\r\n\r\n  zahl:=strtoint(edit1.text);   // Schreibe die Zahl aus dem ersten Textfeld auf zahl\r\n  isPrim := true;               // initalisiere Variable isPrim mit true, wird ggf. später auf false gesetzt\r\n  i:=2;                         \r\n\r\n  while (i = zahl-1) do        // gehe alle möglichen Teiler zwischen 2 und zahl-1 durch und ...\r\n  begin                         \r\n    if  (zahl mod i = 0) then   // ... prüfe ob i die Zahl zahl glatt, also ohne Rest, teilt\r\n      isPrim := false;          // wenn ja, dann ist zahl keine Primzahl und daher wird isPrim auf false gesetzt\r\n    i:=i+1;                     // erhöhe i, also versuche den nächsten Teiler\r\n  end;\r\n\r\n  if (isPrim = true) then       // Wenn nach der Schleife isPrim immer noch true ist, dann \r\n    edit2.text := inttostr(zahl)+ \' ist eine Primzahl.\'   \r\n  else\r\n    edit2.text := inttostr(zahl)+ \' ist keine Primzahl.\';\r\n\r\nend;                                                             \r\n\r\n[/code]\r\n[break]\r\nIn diesem Beispiel bleibt man so lange in der Schleife wie die Bedinung i Endlosschleife[/big]". Diese kann man glücklicherweise in der Delphi-IDE mit der Stopp-Taste beenden. [break][break]\r\n\r\nAls letzte Schleife soll an dieser Stelle die [big]repeat-until-Schleife[/big] vorgestellt werden. Diese Schleife gehört zu den [big]fußgesteuerten[/big] Schleifen. Fußgesteurte Schleife haben im Gegensatz zu den [big]kopfgesteuerten[/big] Schleifen ihr Bedinung am Ende des Schleifenkörpers. Daher wird bei den fußgesteuerten Schleifen der Wiederholungscode mindestens einmal durchlaufen. Auch hierzu ein Beispiel: [break]\r\n\r\n[code]\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\n  var zahl           : integer;\r\n      i,schrittweite : real;  // Kommazahlen\r\nbegin\r\n\r\n  zahl:=strtoint(edit1.text); \r\n  i:=0;\r\n  schrittweite := 0.001;                                // Schrittweite zum herantasten an die Wurzel\r\n  repeat\r\n    i:=i+schrittweite;                                  // Erhöhe um Schrittweite\r\n  until (i*i = zahl);                                  // Breche Schleife ab, wenn Wurzel (fast) erreicht\r\n\r\n  edit2.Text:= (\'MeinProgramm:\' +floattostr(i)+         // Gebe den vom Programm berechneten Wert aus\r\n                \' Delphi :\'+floattostr(sqrt(zahl)));    // und den Vergleichswert über dei Wurzel-Fkt.\r\n\r\nend;\r\n\r\n[/code] [break]\r\nZum Schluss noch ein Beispiel, wie die Schleife mit ihrer Abbruchbedingung/Wiederholungsbedingung in einem Flussdiagramm dargestellt wird:[break]\r\n[break][break]\r\n\r\n\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Schreibe das zum Flussdiagramm gehörige Programm.[/task]\r\n  [task]Schreibe ein Programm mit vielen Schleifen und probiere alle Schleifentypen gut aus.[/task]\r\n  [task]Ergänze obiges Wurzelprogramm um notwendige Überprüfungen der Eingabe. (z.B. ob Zahl = 0)[/task]\r\n  [task]Zeichne zum Primzahlbeispiel das dazugehörige Flussdiagramm.[/task]\r\n  [task]Das Beispiel mit dem Primzahlentest ist nicht sehr effektiv. Es werden viele unnötige Schritte gemacht. Will man die Zahl 123456789 testen, so benötigt das Programm 123456787 Durchläufe. Verbessere das Programm und ermittel, wie viele Durchläufe nun für folgende Zahlen nötig sind:\r\n      \r\n       [li]16[/li]\r\n       [li]7[/li]\r\n       [li]12347[/li]\r\n       [li]123456789[/li]\r\n      \r\n      Gebe das neue Primzahltestprogramm ab. \r\n  [/task]\r\n \r\n[/tasks]\r\n\r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(66, 'cNjVjZmM0OGViYmU:', 0, 1446469032, 5, 5, 1446469032, 3, 12, 'Prozeduren', '[headline]Kapitel 11 - Prozeduren[/headline] \r\nDieses Kapitel beschäftigt sich mit den Prozeduren. Diese ermöglichen es eine Sammlung von Anweisungen zu einer Anweisung zusammenzufassen. Das macht in aller erster Linie das Programm übersichtlicher und erspart ein viel Schreibarbeit, da man nur einmal eine Prozedure anlegen muss und kann diese dann beliebig oft aufrufen. Die Prozedur muss vor ihrem Aufruf angelegt werden.[break]\r\nWir haben übrigens schon häufiger Prozeduren angelegt. Jedes Mal wenn wir ein Ereignis einrichten, erstellt uns die IDE automatisch die dazugehörige Prozedur und lässt uns dann nur noch den Inhalt füllen. Nun möchten wir aber ganz eigene Prozeduren erstellen. Dazu benutzt man erst das Schlüsselwort [big]procedure[/big], gefolgt von seinem Namen, den wir der Prozedur geben wollen und letztlich das obligatorische Semikolon.\r\n\r\n[code]\r\n...\r\nimplementation             // wird von der Delphi-IDE automatisch erstellt\r\n{$R *.dfm}                 // wird von der Delphi-IDE automatisch erstellt\r\n			   // Hier schreibt man seine eigenen Prozeduren hin\r\n\r\nprocedure ClearAllFields;  // Erstellen der Prozedur ClearAllFields\r\nbegin\r\n  Form1.edit1.text:=\'\';    // Leeren der 2 Textfelder und eines Memofelds\r\n  Form1.edit2.text:=\'\';    // Das passiert aber erst dann, wenn die Prozedur\r\n  Form1.Memo1.Clear;       // aufgerufen wird.\r\nend;\r\n                           // nach den eigenen Prozeduren folgend die Ereignisse\r\n\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\nbegin\r\n  ClearAllFields;          // Aufruf der Prozedur. Erst HIER werden die Felder geleert.\r\n  Edit1.Text:=\'Yes\';       // Neuer Inhalt in Edit1\r\nend;                       \r\n\r\n...\r\n[/code] [break]\r\n\r\nMan beachte in diesem Beispiel, dass man in der Prozedur alle angesprochenen Objekte vollständig referenzieren muss. Also: Formular.Komponente.Eigenschaft [break]\r\nIm Gegensatz dazu ist die Ereignisprozedur TForm1.Button1Click schon eine [big]Methode[/big] (das sind Prozeduren und Funktionen die auf Objekten arbeiten) vom Formular Form1. Daher kann man es sich dort sparen vor allen Komponenten "Form1." zu schreiben. (siehe Kapitel 3)[break][break]\r\n\r\nKommen wir aber nun zu den etwas interessanteren Prozeduren, denen mit [big]Parametern[/big]. Häufig möchten wir nämlich noch etwas der Prozedur mit "auf den Weg geben" . Dafür gibt es dann den Parameter. Dieser wird beim Aufruf in Klammern mitübergeben. Bei der Erstellung der Prozedur behandelt man die Parameter wie ganz normale Variablen.Auch sie haben einen Namen und einen Typ. Den Wert bekommen sie beim Aufruf der Prozedur übergeben. Hier ein Beispiel, was vieles erklärt:[break] \r\n\r\n[code]\r\nprocedure FillAllFields(content : String);       // Prozedur erwartet einen Parameter und legt den übergebenen\r\nbegin                                            // Parameter auf den String content ab.\r\n  Form1.edit1.text:=content;                     // Setzt Textfelder auf den Wert von content\r\n  Form1.edit2.text:=content;\r\n  Form1.Memo1.Clear;                             // Leert Memofeld\r\n  Form1.Memo1.Lines.add(content);                // und schreibt den Wert von content ins Memo\r\nend;\r\n\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\nbegin\r\n  FillAllFields(\'Pack mich rein\');               // Ruft die Prozedur FillAllFields auf und übergibt den \r\nend;                                             // Wert \'Pack mich rein\' an die Prozedur\r\n[/code] [break]\r\n\r\nNatürlich kann man auch Variablen vom Typ Integer, Real oder Boolean übergeben. Auch kann man ohne weiteres Prozeduren erstellen, die mehrere Parameter erwarten. Hier ein weiteres Beispiel, diesmal aber ohne Kommentare. [break]\r\n\r\n[code]\r\nprocedure NerveUser(wieoft:integer; womit : string);\r\n var i : integer;\r\nbegin\r\n  for i:= wieoft downto 1 do\r\n    Showmessage (womit + \' | noch \'+ inttostr(i)+ \' Nachrichten\');\r\nend;\r\n\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\nbegin\r\n  NerveUser(5,\'Nerve schön\');\r\nend;\r\n[/code] [break]\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Suche im Internet nach der Prozedur [big]Showmessage[/big] und probiere sie mit unterschiedlichen Parametern aus.[/task]\r\n  [task]Was ist der Unterschied zwischen normalen Formularen und Dialogboxen (wie z.B. Showmessage)?[/task]\r\n  [task]Was macht die obige Prozedur "NerveUser"? Kommentiere die einzelnen Zeilen nachträglich (im Heft oder auf dem PC)[/task]\r\n  [task]Erstelle eine Prozedur isPrim, die eine ganze Zahl als Parameter erwartet und über Showmessage ausgibt, ob es sich um eine Primzahl handelt oder nicht.[/task]\r\n \r\n[/tasks]\r\n\r\nUm ins nächste Level zu kommen gib folgenden Code in die erste Zeile des Eingabefeldes ein. Dabei darauf achten, dass die Laufzeitinterpretation angehakt ist.  document.write(NxtLvCode);  \r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(67, 'cYmY4MzJiNzdkNDE:', 0, 1446469053, 5, 5, 1446469053, 3, 13, 'Funktionen', '[headline]Kapitel 12 - Funktionen[/headline] \r\nFunktionen sind mit die wichtigsten Sachen der Programmierung. Es verlangt ein wenig Geschick geeignete Funktionen zu\r\nerstellen. Dabei sind Funktionen im Grunde nichts wirklich Neues. Sie sind so ähnlich wie Prozeduren, haben aber zudem\r\nnoch gewisse Eigenschaften einer Variable. Zudem haben wir schon mehrfach Funktionen aufgerufen, nun werden wir solche\r\nauch noch selber erstellen. Die Besonderheit einer Funktion ist, dass sie immer einen (genau einen) Wert zurückliefert. \r\nIm Vergleich dazu, eine Prozedur liefert keine Werte zurück. Auch eine Funktion kann mehrere Parameter besitzen.[break][break]\r\n\r\nSchauen wir aber zunächst einmal auf ein paar Beispiele, wo wir schon Funkionen aufgerufen haben:[break]\r\n\r\n[code]\r\n  a := sqrt(67);          // sqrt ist eine Funktion, sie erwartet als Parameter eine Zahl als Eingabe\r\n                          // und liefert die Wurzel dieser Zahl zuück\r\n  a := strtoint(\'789\');   // strtoint ist auch eine Funktion, sie erhält einen String als Parameter\r\n                          // und liefert eine Zahl zurück\r\n  showmessage (\'Hallo\');  // Ist KEINE Funktion, diese Prozedur gibt zwar etwas auf dem Bildschirm aus,\r\n                          // liefert aber keinen Wert zurück, mit den man weiterarbeiten könnte.\r\n[/code] [break]\r\n\r\nMan kann also auf Funktionen zurückgreifen, wie auf Variablen. Allerdings kann man nur lesend zurückgreifen. Logisch, \r\neine Anweisung wie: sqrt(67) := 5; macht keinen Sinn.[break][break]\r\n\r\nNun möchten wir diese Funktionen aber auch selber erstellen. Dies macht man im Grunde genauso wie mit Prozeduren. Das\r\nSchlüsselwort ist in diesem Fall aber "[big]function[/big]". Außerdem muss man noch nach der Parameterklammer angeben, von \r\nwelchem Typ der Rückgabewert ist. Dazu ein einfaches Beispiel:\r\n\r\n[code]\r\n\r\nfunction add (a,b:integer) : integer; // Hier wird die Funktion definiert, sie hat die Eingabeparameter a,b vom\r\nbegin                                 // Typ integer und liefert ebenfalls einen Wert vom Typ integer zurück\r\n  result := a + b;                    // result ist eine spezielle "Variable", sie weist der Funktion einen Wert zu\r\nend;\r\n\r\nfunction fakultaet (zahl:integer) : integer; // Definiert die Funktion fakultaet, die einen integer als Parameter\r\n var i,produkt : integer;                    // erwartet und selber einen integer zurückliefert\r\nbegin\r\n  produkt:=1;                               \r\n  for i:= 1 to zahl do                       // geht in einer Schleife i von 1 bis zahl durch und\r\n    produkt:=produkt * i;                    // multipliziert die einzelnen Zahlen in produkt auf.\r\n  result := produkt;                         // Hier wird dann das Ergebnis der Schleife der Funktion \r\nend;                                         // zugewiesen\r\n\r\n\r\nprocedure TForm1.Button1Click(Sender: TObject);\r\nbegin\r\n  Edit2.Text := inttostr(fakultaet(strtoint(edit1.text)));  // Mehrfach verschachtelter Aufruf mehrerer Funktionen\r\nend; \r\n\r\n[/code] [break]\r\n\r\nFunktionen sind insoweit wichtig, dass man an in diesen ganze Arbeitsanweisungen definieren kann. Ruft man sie dann \r\nauf und übergibt entsprechende Parameter, so verarbeitet die Funktion ihre Parameter und liefert ihr Ergebnis zurück.\r\nDas hält den Code sauber, da man so z.B. bei der Wurzel überhaupt nichts vom komlizierten Algorithmus der Wurzel\r\nmitbekommt, sondern man lediglich sqrt() aufruft und das Ergebnis erhält. Die eigentliche Berechnung der Wurzel steht\r\ndabei an einer ganz anderen Stelle. Zudem muss man diesen Code auch nur einmal schreiben und kann ihn aber dann in \r\nseinem Programm mehrfach aufrufen. Man deligiert also ein Stück weit die Arbeit bzw. lagert Codeteile in Funktionen\r\naus.[break][break]\r\n\r\nWir haben schon im 3. Kapitel das Prinzip der Wiederverwendbarkeit kennengelernt. Dieses kommt bei den Funktionen \r\nebenfalls vor, da man einmal geschrieben Code (den in der Funktion) an unterschiedlichen Stellen, mehrfach aufrufen \r\nkann. Neben diesem Prinzip kommt aber auch ein weiteres Prinzip zum Tragen. Das [big]EVA-Prinzip[/big] (EVA steht für \r\nEingabe-Verarbeitung-Ausgabe) spielt in vielen Bereichen der Informatik eine wichtige Rolle. Bei den Funktionen \r\nübergeben wir einen Parameter (z.B. der Funktion sqrt die 16), das ist die Eingabe. Die Funktion verarbeitet den \r\nParameter (Verarbeitung) und liefert schließlich das Ergebnis, in unserem Beispiel die 4, zurück (Ausgabe).[break]\r\nWie gesagt trifft das EVA-Prinzip, wie alle anderen Prinzipien der Informatik, auch in ganz anderen Zusammanhängen\r\nauf. Der PC an sich hat auch Eingabegeräte (Maus, Tastatur, Scanner, Mikrofon, ...), verarbeitet diese Daten und \r\ngibt dann wieder Sachen über Monitor, Drucker, Lautsprecher, ... aus. Aber auch der Prozessor an sich unterliegt \r\ndiesem Prinzip.\r\n\r\n\r\n[tasks]\r\n\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Finde mindestens ein weiteres Beispiel für das EVA-Prinzip und schreibe es in deinen Hefter.[/task]\r\n  [task]Erstelle eine Funktion add3(), die 3 übergebene Parameter addiert und sie Summe zurückliefert[/task]\r\n  [task]Erstelle eine Funktion isPrim(), die überprüft, ob eine Zahl eine Primzahl ist oder nicht. Dafür\r\n      soll die Funktion einen boolean (true oder false) zurückgeben. [/task]\r\n  [task]Erstelle eine Funktion sum, die eine Zahl als Eingabeparameter erwartet und die Summe von 1 bis zu dieser Zahl zurückgibt.[/task]\r\n  [task](optional) Erstelle eine Funktion mysqrt, der man eine natürliche Zahl übergibt und deren Wurzel berechnet. Nutze dazu das\r\n       Intervallschachtlungs- oder Heronverfahren.[/task]\r\n \r\n[/tasks]\r\n\r\nGebe die Aufgaben 4 und 5 (und ggf. auch die 6) in einem Projekt ab, um in das nächste Level zu gelangen.\r\n', 0, 0, '', 0, 0, 1, ''),
	(68, 'cYmE5YTcyYjRlYjc:', 0, 1446469094, 5, 5, 1446469094, 3, 14, 'Arrays', '[headline]Kapitel 13 - Arrays [/headline]\r\n\r\nManchmal benötigt man ziemlich viele Variablen, dann ist es etwas problematisch immer wieder neue anzulegen. Auch \r\ndie Mathematik kennt das Problem und benutzt dann statt der Variablen a, b, c, ... die Variablen a1, a2, a3, ...[break]\r\n\r\nDas gleiche Prinzip kann man auch in der Informatik nutzen. Hier heißen solche indizierten Variablen [big]Arrays[/big]. Statt\r\nder Variable a, b, c, ... legt man sich hier die Variable a[1], a[2], a[3], ... an. Auch diese Variablen müssen einen\r\nbestimmten Typ besitzen. Möchte man sich zum Beispiel die Belegung von einem Schachbrett merken, so kann man sich ein\r\nArray vom Typ String anlegen, dass von 1 bis 64 indiziert.\r\n\r\n[code]\r\n var i : integer;\r\n var schachbrett: array[1..64] of string; // Legt sich ein Array namens schachbrett vom Typ string an\r\nbegin                                     // Das Array akzeptiert einen Index zwischen 1 und 64\r\n  for i  := 1 to 64 do                    // Gehe alle 64 Felder durch und ...\r\n    schachbrett[i]:=\'\';                   // ... weise diesen einen leeren String zu\r\n  schachbrett[1]:=\'Turm\';                 // Weise dem ersten Feld den Wert \'Turm\' zu\r\n  schachbrett[2]:=\'Springer\';             // usw ...\r\n  schachbrett[3]:=\'Läufer\';\r\n  schachbrett[4]:=\'Dame\';\r\n  // ...\r\nend;\r\n[/code] [break]\r\nDas obige Bespiel beschreibt ein sogenanntes eindimensionales Array. Manchmal möchte man aber auch Daten 2-dimensional\r\nablegen (also in einer Art Tabelle). Dann kann man sich auch ein [big]2-dimensionales Array[/big] erstellen. Gerade beim Schach\r\nwürde sich ein 2-dimensionales Array anbieten, da auch die Felder auf dem Schachbrett in mehrere Zeilen und Spalten\r\nunterteilt sind. Folgendes Beispeil verdeutlicht die Idee und die dazugehörige Syntax.\r\n\r\n[code]\r\n var i1,i2 : integer;\r\n var schachbrett: array[1..8,1..8] of string;\r\nbegin\r\n  for i1  := 1 to 8 do\r\n    for i2  := 1 to 8 do\r\n      schachbrett[i1,i2]:=\'\';\r\n  schachbrett[1,1]:=\'Turm\';\r\n  schachbrett[2,1]:=\'Springer\';\r\n  schachbrett[3,1]:=\'Läufer\';\r\n  schachbrett[4,1]:=\'Dame\';\r\nend;\r\n[/code] [break]\r\n\r\nWie man sieht hat jetzt das Array zwei Indizies. Sie rechnen jeweils von 1 bis 8. So ergeben sich ebenfalls 64 Felder. Der\r\ngroße Unterschied ist, dass man sich so die Lage der Felder besser vorstellen kann und so besser und übersichtlicher\r\nprogrammieren kann. Selbstverständlich kann man auch Arrays mit noch mehr Dimensionen anlegen. Dies kommt aber in der\r\ngängigen Programmierpraxis eher selten vor. [break][break]\r\n\r\nWeitere Beispiele für Arrays sind: [break]\r\n[code]\r\nVierGewinntFeld: array[1..7,1..6] of char; // entweder \' \' für leer oder \'g\' für gelb, \'r\' für rot\r\nNamensliste: array[1..1000] of string;     // hier kann man zum Beispiel eine Liste aller Schüler der Schule \r\n                                           // oder Klasse anlegen. Man sollte sich dann aber noch eine Variable\r\n                                           // NamenslisteCount vom Typ integer anlegen, in der man ablegt, wie \r\n                                           // viele Einträge das Array derzeit besitzt. So kann man auch zur \r\n                                           // Laufzeit weitere Einträge hinzufügen, so lange man nicht über \r\n                                           // 1000 Einträge kommt.\r\nUserListe: Array[1...9999] of TUser;       // Eine Liste von Usern. Hier gibt es etwas besonderes, TUser ist \r\n                                           // ein eigener Datentyp, den man vorher über das Schlüsselword\r\n                                           // [big]record[/big] angelegt hat. \r\n[/code] [break]\r\n\r\n\r\n[tasks]\r\n\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Finde mindestens drei weitere Beispiele für sinnvolle Arrays[/task]\r\n  [task]Erstelle ein Programm, wo man in einem Textfeld beliebig viele Namen nacheinander eingeben kann. Die Namen werden nach dem \r\n      Drücken vom Speichern-Button auf ein Array gelegt. Mit Drücken auf den Ausgabe-Button werden alle bisher eingegebenen Namen\r\n      Nacheinander in einer Messagebox ausgegeben. Gebe das Programm ab[/task]\r\n \r\n[/tasks]\r\n\r\n\r\n', 0, 0, '', 0, 0, 1, ''),
	(69, 'cOWFkZjZlYTdkODQ:', 0, 1446469111, 5, 5, 1446469111, 3, 15, 'Verbund', '[headline]Kapitel 14 - Verbund [/headline]\r\nManchmal möchte man nicht nur einen String oder einen Integer speichern, sondern einen ganzen Datensatz aus verschiedensten \r\nVariablentypen. Dort hilft uns der so genannte [big]Verbund[/big]. In Delphi lautet der dazugehörige Befehl [big]"record"[/big]. Der \r\nVerbund ist auch in gewisser Weise eine Vorstufe zur objektorientierten Programmierung.  Man legt sich mit Record keine \r\nVariable, sondern im Grunde einen eigenen Variablentyp an. Nun, wie funktioiert er? Schauen wir uns einfach mal ein \r\nBeispiel an:[break]\r\n\r\n[code]\r\n\r\nTYPE TPerson =                  // Anlegen des Records (Es ist ersteinmal eine Vorlage und kann keine Werte beinhalten)\r\n    RECORD                      // Es ist in Delphi üblich, die Namen solcher Records mit T zu beginnen.\r\n       Vorname    : String;     // TPerson beinhaltet diese 3 Datenfelder (auch [big]Attribute[/big] genannt) \r\n       Name       : String;\r\n       Alter      : Integer;       \r\n    END;                        // Nachdem nun die Definition unseres neuen Datentyps abgeschlossen ist, müssen wir nur\r\n                                // noch eine Variable von diesem neuen Typ erzeugen ([big]instanziieren[/big]).\r\n                                // Achtung: TPerson ist keine Variable, sie wird nie Werte beinhalten!\r\n \r\n \r\nProcedure blabla;\r\nVAR Mustermann: TPerson;        // Erzeugt eine [big]Instanz[/big] von TPerson mit den Namen Mustermann (instanziieren)\r\n                                // (Deklariert eine Variable namens Mustermann vom Typ TPerson) \r\n begin\r\n    Mustermann.Vorname          := \'Hans\';        //Setzt die einzelnen Werte in Mustermann\r\n    Mustermann.Name             := \'Mustermann\';\r\n    Mustermann.Alter            := 32;\r\n end;\r\n\r\n[/code] [break]\r\nMan kann sich den Record vorstellen, wie eine Vorlage oder einen neuen Variablentypen. Aber Achtung, wenn man es genau nimmt,\r\nist es kein neuer Typ. Es ist ein [big]Verbund[/big]. Dieser hat [big]Attribute[/big] und muss [big]instanziiert[/big] werden.[break][break]\r\n\r\nMeinstens wird der Verbund im Zusammenhang mit einem Array benutzt. Im obigen Beispiel hätte man ja einfach auch nur einen\r\nMustermann_Vorname,Mustermann_Name und Mustermann_Alter vom Typ String bzw. Integer anlegen können. Das wäre auch fast noch\r\nsauber gewesen. Möchte man aber mehrere Personen in Variblen ablegen, dann kommt der Record erst richtig zum Einsatz:\r\n\r\n[code]\r\n\r\nTYPE TPerson =                  // Anlegen des Verbunds\r\n    RECORD                      \r\n       Vorname    : String;     \r\n       Name       : String;\r\n       Alter      : Integer;       \r\n    END;                   \r\n \r\nProcedure blabla;\r\nVAR Person : Array[1..100] of TPerson;  // Erzeugt ein Array von TPerson\r\n begin\r\n   Person[1].Vorname := \'Heinz\';        // Setzt im Arrayindex 1 die Werte.\r\n   Person[1].Name    := \'Mustermann\'; \r\n   Person[1].Alter   := 56; \r\n end;\r\n\r\n[/code] [break]\r\n\r\nJetzt können wir die Datensätze später auch recht einfach in eine Datei schreiben oder diese Daten über eine Schleife \r\nschnell durchsuchen oder ausgeben lassen. [break][break]\r\n\r\nZum Schluss möchte ich noch kurz darauf aufmerksam machen, dass man auch Records im Record benutzen kann. Zum Beispiel\r\nist es derzeit nur möglich das Alter im Datensatz abzuspeichern. Besser wäre es aber, wenn wir uns das Geburtsdatum im\r\nVerbund speichern könnten. Wenn man so etwas sauber programmieren möchte, legt man sich zunächst ein Record namens TDatum\r\nan und definiert darin die Attribute Tag, Monat und Jahr (z.B. als Integer). Dann legt man sich den Verbund TPerson an \r\nund hat statt Alter dann das Attribut GebDatum vom Typ TDatum. Dieses Gebdatum kann man dann über Person[1].GebDatum.Jahr \r\nsetzen bzw. auslesen.\r\n\r\n[tasks]\r\n\r\nAufgaben: [break]\r\n \r\n  [task]Notiere dir wie immer die wichtige Inhalte in deinem Hefter. Insbesondere die fettgedruckten Wörter sind wichtig.[/task]\r\n  [task]Schreibe ein kurzes Programm, dass wie oben beschrieben mit TDatum und TPerson arbeitet.[/task]\r\n  [task](opt) Schreibe ein Programm, wo man bis zu 100 Datensätze eingeben kann.[break]\r\n      [break]\r\n      Mit den Pfeil-Knöpfen kann man durch die Einträge blättern. Gibt man einen Eintrag ein und drückt dann auf den speichern-\r\n      Button, so werden die Daten des Datensatzes im Array abgelegt. Beim Knopf "löschen" werden die Eingabefelder gelöscht.\r\n      Die Datensatznummer gibt die Nummer des aktuellen Datensatzes an. Diesen solltet ihr zunächst auf "readonly" setzen. \r\n      Wer will kann später aber auch das Programm so ergänzen, dass man dort eine Datensatznummer angeben kann und das \r\n      Programm zu diesem Datensatz springt.\r\n  [/task]\r\n  [task](opt) Wer jetzt immer noch nicht den Hals vollbekommt, der darf noch ein SaveToFile und LoadFromFile-Knopf anlegen.\r\n      Schaut euch dazu in der Toolpalette die Dialoge (TOpenDialog, TSaveDialog) an. Achtung, die Dinger speichern und laden\r\n      selber nicht, sondern lassen dich nur einen Speicherplatz aussuchen. Zum eigentlichen Laden und Speichern, solltest\r\n      du entweder eine Textfile nutzen und Zeile für Zeile speichern bzw Laden ODER eine binäre Datei und dort die Datensätze\r\n      an sich übergeben. Suche dazu folgende Sachen bei google: "Delphi textfile", "Delphi blockread", "Delphi record speichern"\r\n  [/task]    \r\n \r\nGebe Nummer 2 ab. Wenn du dich an einer der optionale Aufgaben probieren möchtest, dann gebe stattdessen diese ab.\r\n[/tasks]\r\n', 0, 0, '', 0, 0, 1, ''),
	(70, 'cZjJiMjhiNzZlM2U:', 0, 1446469132, 5, 5, 1446469143, 3, 16, 'Timer', '[headline]Kapitel 15 - Timer[/headline]\r\nEinen Timer kann man sich wie eine Art Eieruhr vorstellen. Wenn er eingeschaltet (enabled := true) ist, dann zählt er eine bestimmte Zeit runter und fängt dann wieder von vorne an, bis man ihn ausschaltet (enabled := false). Um einen zu erstellen, sucht man einfach in der Toolpalette nach "TTimer" und zieht ihn dann auf das Formular. Man kann bei den Eigenschaften eines Timers das Interval angeben, also der Abstand in Millisekunden wann der Timer aufgerufen werden soll. Unter Ereignisse findet man das Ereigniss OnTimer, in der steht was passiert, wenn der Timer aufgerufen wird.[break][break]\r\n\r\n[break][break]\r\n\r\n[code]\r\n\r\nprocedure TForm1.Timer1Timer(Sender: TObject);\r\nbegin\r\n  Image1.Left := Image1.Left + 1;\r\nend;\r\n\r\n[/code] [break]\r\n\r\nBei diesem Beispiel wird das Bild jede Sekunde (Timer1.Interval := 1000) um einen Pixel nach rechts bewegt.\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Experimentiere ein bisschen mit dem Timer rum, lass das Bild schneller laufen usw.[/task]\r\n  [task]Wenn man an auf dem Button klickt, soll sich ein Bild bewegen. Klickst du auf einen anderen Button, bleibt das Bild stehen. Du kannst auch noch einen Button machen, der z.B. das Bild schneller bewegen lässt.[/task]\r\n \r\n[/tasks]\r\n', 0, 0, '', 0, 0, 1, ''),
	(71, 'cZTc3MmY3MGIyZTM:', 0, 1446469173, 5, 5, 1446469173, 3, 17, 'Pong', '[headline]Kapitel 16 - Pong[/headline]\r\n\r\nNun da wir wissen, wie wir ein Bild bewegen können. Kommen wir nun zur Kunst der Kollision. Wir werden das Bild mit dem Rand der Form kollidieren lassen. Es gibt nicht nur die Kollision mit dem Rand, aber es ist für den Einstieg am Besten geeignet. In dem Spiel Pong lässt man einen Ball an dem Rand abprallen. Wir haben erst mal eine vereinfachte Version gemacht, der Ball bzw. das Image prallt nur von der rechten und von der linken Wand ab.\r\n\r\n[code]\r\n\r\nvar\r\n  movement: Integer;  //Die Anzhal der Pixel um die sich der Ball bei jedem Timer aufruf bewegen soll\r\n\r\n\r\nprocedure TForm1.FormCreate(Sender: TObject);\r\nbegin\r\n  movement := 2;   //Hier wird movement auf 2 gesetzt\r\n  form1.Width := 260;\r\n  Image1.Left := 0;\r\nend;\r\n\r\nprocedure TForm1.Timer1Timer(Sender: TObject);\r\nbegin\r\n  Image1.Left := Image1.Left + movement;                //Bild wir um movement (2) nach rechts versetzt\r\n  if Image1.Left + Image1.Width = Form1.Width then     //Wenn die linke Seite vom Bild(Left) + die Bildbreite\r\n                                                        //größer gleich der Breite des Formulars ist, dann\r\n    begin\r\n      movement := movement * -1;                        //wir movement negativ gesetzt, durch "* -1", damit sich\r\n	                                                    //der Ball nach links bewegt\r\n      Image1.Left := Image1.Left + movement;            //Ball wird um movement (-2) bewegt\r\n    end else if Image1.Left = 0 then                    //oder wenn die linke Seite des Balls mit die linke Seite  \r\n	                                                    //des Formulars kollidiert, dann\r\n    begin\r\n      movement := movement * -1;                        //wird movement positiv gesetzt, durch "* -1", damit sich \r\n	  Image1.Left := Image1.Left + movement;            //das Bild wieder nach rechts bewegt\r\n    end;\r\nend;\r\n\r\n[/code] [break]\r\n\r\nDas Programm ist nur für die Kollision von der linken und rechten Seite. Die Kollision mit oben und unten basiert auf \r\ndem selben Schema.\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Erweitert das Programm so, dass das Ball an allen Seiten abprallen kann.[/task]\r\n  [task](opt)Fügt ein Paddle ein, von dem der Ball auch abprallen kann.[/task]\r\n \r\n[/tasks]\r\n', 0, 0, '', 0, 0, 1, ''),
	(72, 'cOTcyZWE2NDJlMDQ:', 0, 1446469195, 5, 5, 1446469195, 3, 18, 'Programmierprojekt', '[headline]Kapitel 17 - Programmierprojekt[/headline]\r\n\r\n\r\n[tasks]\r\nAufgaben: [break]\r\n \r\n  [task]Schreibe ein Programm mit 2 Textfeldern und zwei Buttons "verschlüsseln" und "entschlüsseln". Drückt man auf "verschlüsseln so soll der Text der ersten Textbox verschlüsselt in der 2. Textbox ausgegeben werden. Dabei sollen ganz einfach alle Buchstaben auf ihren Nachfolger abgeändert werden, also aus a wird b, aus b wird c ... aus z wird wieder ein a. Umlaute müssen dabei nicht berücksichtigt werden.[/task]\r\n  [task]Verändere das Verschlüsselungsprogramm so, dass es auch den Vigenerecode beherrscht (Vigenere: siehe Internet)[/task]\r\n  [task]Schreibe ein schönes TicTacToe-Programm, wo zwei Spieler gegeneinander Spielen können[/task]\r\n  [task](opt)Verändere das TicTacToe-Programm so, dass man auch optional einen Computergegener auswählen kann, der gegen den Menschen antritt[/task]\r\n  [task]Schreibe ein Hangmanprogramm[/task]\r\n  [task](schwer) Schreibe ein 4-Gewinnt-Programm[/task]\r\n \r\n[/tasks]\r\n\r\nHier Endet das erste Thema "Delphi imperativ"!\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0, 0, '', 0, 0, 1, '');
/*!40000 ALTER TABLE `chapter` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.cloud
CREATE TABLE IF NOT EXISTS `cloud` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nTreeLeft` int(11) unsigned NOT NULL,
  `nTreeRight` int(11) unsigned NOT NULL,
  `sType` varchar(100) NOT NULL,
  `sName` varchar(255) NOT NULL,
  `bFilesystem` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `sFile` text NOT NULL,
  `bOpen` tinyint(2) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId_bDeleted` (`sHashId`,`bDeleted`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.cloud: ~4 rows (ungefähr)
/*!40000 ALTER TABLE `cloud` DISABLE KEYS */;
INSERT INTO `cloud` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nTreeLeft`, `nTreeRight`, `sType`, `sName`, `bFilesystem`, `sFile`, `bOpen`) VALUES
	(1, 'cZDg3OGMwM2JhYTY:', 0, 1445958981, 1445958981, 5, 1, 6, 'folder', 'Admin@test.des Dateien', 0, '', 0),
	(2, 'cZjU4YjljOTRjMGQ:', 0, 1446139206, 1446139206, 6, 1, 2, 'folder', 'Admin2@test.des Dateien', 0, '', 0),
	(3, 'cNWNhODdkNTIzZjM:', 0, 1446217793, 1446217822, 5, 2, 3, 'text/plain', 'test', 0, '<html> ', 1),
	(4, 'cZGJiZDlmMzk5ZTA:', 0, 1446217830, 1446217933, 5, 4, 5, 'text/plain', 'test.html', 0, '<html>\n  <div>afs</div>  \n    \n</html>', 0);
/*!40000 ALTER TABLE `cloud` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.group
CREATE TABLE IF NOT EXISTS `group` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `sName` varchar(255) NOT NULL,
  `nIdInstitution` int(11) unsigned NOT NULL,
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId` (`sHashId`,`bDeleted`)
) ENGINE=MyISAM AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.group: 6 rows
/*!40000 ALTER TABLE `group` DISABLE KEYS */;
INSERT INTO `group` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `sName`, `nIdInstitution`) VALUES
	(1, 'gUqzmrOt9kLDQUqH:', 0, 0, 0, 0, 0, '9GAG', 1),
	(2, 'gzVNi0H8gPVtS2LD:', 0, 0, 0, 0, 0, '10GAG', 1),
	(3, 'g1sVSGtql8QhLXBQ:', 0, 0, 0, 0, 0, '9VGH', 2),
	(4, 'gCThjuDxTy2IUZR2:', 0, 0, 0, 0, 0, '10VGH', 2),
	(5, 'gEQQbNUVBdBD5sPQ:', 0, 0, 0, 0, 0, '9Test', 3),
	(6, 'gpcAwLRtPpXQV0Pt:', 0, 0, 0, 0, 0, '10Test', 3);
/*!40000 ALTER TABLE `group` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.handin
CREATE TABLE IF NOT EXISTS `handin` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `nCreate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdGroup` int(11) unsigned NOT NULL,
  `nIdChapter` int(11) unsigned NOT NULL,
  `sInterpreter` text NOT NULL,
  `sCloud` text NOT NULL,
  `bCurrentlyUnderReview` tinyint(2) unsigned NOT NULL DEFAULT '1',
  `nRound` int(2) unsigned NOT NULL DEFAULT '1',
  PRIMARY KEY (`nId`),
  UNIQUE KEY `nIdCreator_nIdGroup_nIdChapter` (`nIdCreator`,`nIdGroup`,`nIdChapter`),
  UNIQUE KEY `sHashId` (`sHashId`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.handin: 0 rows
/*!40000 ALTER TABLE `handin` DISABLE KEYS */;
/*!40000 ALTER TABLE `handin` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.help
CREATE TABLE IF NOT EXISTS `help` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `nCreate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdHelpcall` int(11) unsigned NOT NULL,
  `sResponse` varchar(255) NOT NULL,
  `bHelpful` tinyint(2) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`nId`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.help: 0 rows
/*!40000 ALTER TABLE `help` DISABLE KEYS */;
/*!40000 ALTER TABLE `help` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.helpcall
CREATE TABLE IF NOT EXISTS `helpcall` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `nCreate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdChapter` int(11) unsigned NOT NULL,
  `nIdGroup` int(11) unsigned NOT NULL,
  `nUsersReached` int(3) unsigned NOT NULL,
  `sQuestion` varchar(255) NOT NULL,
  `eStatus` enum('open','request','done','withdrawn') NOT NULL DEFAULT 'open',
  PRIMARY KEY (`nId`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.helpcall: 0 rows
/*!40000 ALTER TABLE `helpcall` DISABLE KEYS */;
/*!40000 ALTER TABLE `helpcall` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.institution
CREATE TABLE IF NOT EXISTS `institution` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `sName` varchar(255) NOT NULL,
  `sDomain` varchar(10) NOT NULL,
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId` (`sHashId`,`bDeleted`)
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.institution: 3 rows
/*!40000 ALTER TABLE `institution` DISABLE KEYS */;
INSERT INTO `institution` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `sName`, `sDomain`) VALUES
	(1, 'iZjE4NzQ4Y2NiODI:', 0, 1445343319, 1445343319, 5, 5, 'GAG', 'school'),
	(2, 'iZGFiZDE5N2M3N2Q:', 0, 1445343335, 1445343335, 5, 5, 'VideoGameHighschool', 'school'),
	(3, 'iODMxZjNiNTdhY2U:', 0, 1445343355, 1445343355, 5, 5, 'TestSchool', 'school');
/*!40000 ALTER TABLE `institution` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.module
CREATE TABLE IF NOT EXISTS `module` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `sName` varchar(255) NOT NULL,
  `sDescription` varchar(800) NOT NULL,
  `sImage` varchar(100) NOT NULL,
  `bLive` tinyint(2) NOT NULL DEFAULT '0',
  `sDomain` varchar(10) NOT NULL DEFAULT '0',
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId` (`sHashId`)
) ENGINE=MyISAM AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.module: 5 rows
/*!40000 ALTER TABLE `module` DISABLE KEYS */;
INSERT INTO `module` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `sName`, `sDescription`, `sImage`, `bLive`, `sDomain`) VALUES
	(1, 'mZDM1MTBjODg3NDg:', 0, 1445343841, 1446472702, 5, 5, 'HTML', '', '', 0, 'school'),
	(2, 'mOTE1YjU0ZjY2ZDA:', 0, 1445343851, 1446472708, 5, 5, 'JavaScript', '', '', 0, 'school'),
	(3, 'mZWQxMmIwNTA5NWE:', 0, 1445343897, 1446472694, 5, 5, 'Delphi', '', '', 1, 'school'),
	(6, 'mOTY5MjFhMDllNTk:', 1, 1445891440, 1445959348, 5, 5, 'SmallBasic', '', '', 0, 'school'),
	(7, 'mODY4MDQ0YjQ5ODE:', 0, 1445967743, 1445967743, 5, 5, 'SmallBasic', '', '', 1, 'school');
/*!40000 ALTER TABLE `module` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.module2group
CREATE TABLE IF NOT EXISTS `module2group` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `nIdModule` int(11) unsigned NOT NULL,
  `nIdGroup` int(11) unsigned NOT NULL,
  PRIMARY KEY (`nId`),
  UNIQUE KEY `nIdModule_nIdGroup` (`nIdModule`,`nIdGroup`,`bDeleted`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.module2group: ~12 rows (ungefähr)
/*!40000 ALTER TABLE `module2group` DISABLE KEYS */;
INSERT INTO `module2group` (`nId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `nIdModule`, `nIdGroup`) VALUES
	(1, 0, 0, 0, 0, 0, 1, 1),
	(2, 0, 0, 0, 0, 0, 2, 1),
	(3, 0, 0, 0, 0, 0, 1, 2),
	(4, 0, 0, 0, 0, 0, 2, 2),
	(5, 0, 0, 0, 0, 0, 1, 3),
	(6, 0, 0, 0, 0, 0, 1, 4),
	(7, 0, 0, 0, 0, 0, 1, 5),
	(8, 0, 0, 0, 0, 0, 2, 5),
	(9, 0, 0, 0, 0, 0, 3, 5),
	(10, 0, 0, 0, 0, 0, 1, 6),
	(11, 0, 0, 0, 0, 0, 2, 6),
	(12, 0, 0, 0, 0, 0, 3, 6);
/*!40000 ALTER TABLE `module2group` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.right
CREATE TABLE IF NOT EXISTS `right` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `nCreate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUser` int(11) unsigned NOT NULL,
  `eType` enum('institution','module','chapter','group') NOT NULL,
  `nIdType` int(11) unsigned NOT NULL,
  PRIMARY KEY (`nId`),
  UNIQUE KEY `nIdUser_eType_nIdType` (`nIdUser`,`eType`,`nIdType`),
  UNIQUE KEY `sHashId` (`sHashId`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.right: ~2 rows (ungefähr)
/*!40000 ALTER TABLE `right` DISABLE KEYS */;
INSERT INTO `right` (`nId`, `sHashId`, `nCreate`, `nIdCreator`, `nIdUser`, `eType`, `nIdType`) VALUES
	(2, 'rNjdjODk0OWE4MDM:', 1445266191, 1, 4, 'module', 1),
	(3, 'rOTNmNTdkNTBmMTc:', 1445347838, 6, 5, 'institution', 0);
/*!40000 ALTER TABLE `right` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.session
CREATE TABLE IF NOT EXISTS `session` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `nCreate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `sSession` varchar(50) NOT NULL,
  `nLastAction` int(35) NOT NULL,
  `sLastAction` varchar(255) NOT NULL,
  PRIMARY KEY (`nId`)
) ENGINE=MyISAM AUTO_INCREMENT=41 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.session: 40 rows
/*!40000 ALTER TABLE `session` DISABLE KEYS */;
INSERT INTO `session` (`nId`, `nCreate`, `nIdCreator`, `sSession`, `nLastAction`, `sLastAction`) VALUES
	(1, 1445005122, 1, '7do9v29pn1ik8204neq85gg124', 1445005288, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(2, 1445262514, 1, '', 1445262520, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(3, 1445262571, 2, '', 1445262602, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(4, 1445262613, 2, '', 1445265121, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(5, 1445265166, 1, '', 1445265514, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(6, 1445265542, 2, '', 1445265613, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(7, 1445265616, 1, '', 1445265635, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(8, 1445265646, 2, '', 1445266002, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(9, 1445266005, 1, '', 1445266422, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(10, 1445266428, 2, '', 1445266855, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(11, 1445266864, 1, 'u4ni9necf6kcj426bdkh50rsv0', 1445267895, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(12, 1445343286, 5, '', 1445346058, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(13, 1445345849, 3, '', 1445346060, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(14, 1445345984, 4, '', 1445346061, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(15, 1445346055, 6, '', 1445346062, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(16, 1445346073, 5, '', 1445346090, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(17, 1445346098, 4, '', 1445346110, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(18, 1445346117, 3, '', 1445346146, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(19, 1445346157, 3, '', 1445346161, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(20, 1445346171, 6, '', 1445350888, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(21, 1445350894, 5, '', 1445351183, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(22, 1445351197, 4, '', 1445351533, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(23, 1445351537, 3, '', 1445351760, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(24, 1445351768, 6, '', 1445353823, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(25, 1445353826, 5, '3qg1l6fds0bg1hndb15kco3gm6', 1445361245, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(26, 1445889719, 5, '', 1445889735, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(27, 1445891415, 5, 'q8ogsh69kvu7gj38506g06ld95', 1445891442, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(28, 1445955174, 5, 'd5idjmsg142uvcmvpsvl6stuu5', 1445955188, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(29, 1445957717, 5, 'v56lj7tk9102dhh4utqls1vil6', 1445973483, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(30, 1446135820, 5, '', 1446138628, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(31, 1446138646, 8, '', 1446138981, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(32, 1446138990, 4, '', 1446139198, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(33, 1446139206, 6, '', 1446142237, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(34, 1446142256, 6, '', 1446142271, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(35, 1446142277, 5, 'pgio6lokvsif8ou1f2ne6qbhf7', 1446142668, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(36, 1446216739, 5, 'aclulvlvkh2cnsbfhpvb5sl4v4', 1446227064, '{"c":"\\\\Iiigel\\\\Controller\\\\Iiigel","a":"cloud"}'),
	(37, 1446409677, 5, '', 1446412438, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(38, 1446412446, 3, '', 1446412528, '{"path":"html\\/logout","c":"\\\\Iiigel\\\\Controller\\\\StaticPage","a":"logout"}'),
	(39, 1446412544, 5, 'uvd7r8efasd9qt7i10c7dspak3', 1446414893, '{"_sHashId":"cODFmOWY0ZDIxYjU:","_sContent":"[headline]Kapitel 13- Arrays[\\/headline]\\r\\nWie ihr wisst speichert man in Variablen immer einzelne Sachen, wie etwa : AnzahlderKekse, Benutzername etc.\\r\\nWas tut man jedoch, wenn man von mehrere Benutzer den '),
	(40, 1446467756, 5, 'u23mhtb0cbsceona1hatadd9o0', 1446475005, '{"_sHashId":"cMTVhYTIyNjcyNzk:","_sContent":"[headline]Kapitel 15 - Buttons und Ereignisse[\\/headline]\\n\\nUm ein Programm besser zu gestalten, reicht es nicht, dem Computer andauernd Befehle zu erteilen, die er dann \\nausf\\u00fchren soll. Deshalb ist es a');
/*!40000 ALTER TABLE `session` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.tags
CREATE TABLE IF NOT EXISTS `tags` (
  `nId` int(11) NOT NULL AUTO_INCREMENT,
  `sTagFrom` tinytext,
  `sTagIn` tinytext,
  PRIMARY KEY (`nId`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.tags: ~13 rows (ungefähr)
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;
INSERT INTO `tags` (`nId`, `sTagFrom`, `sTagIn`) VALUES
	(1, '[headline]', '<h2>'),
	(2, '[/headline]', '</h2>'),
	(3, '[big]', '<b>'),
	(4, '[/big]', '</b>'),
	(5, '[code]', '<div class="code">'),
	(6, '[/code]', '</div>'),
	(7, '[tasks]', '<div class="aufgabe">'),
	(8, '[/tasks]', '</div>'),
	(9, '[task]', '<li>'),
	(10, '[/task]', '</li>'),
	(11, '[break]', '<br>'),
	(12, '[li]', '<li>'),
	(13, '[/li]', '</li>');
/*!40000 ALTER TABLE `tags` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.user
CREATE TABLE IF NOT EXISTS `user` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `sMail` varchar(80) NOT NULL,
  `sName` varchar(80) NOT NULL,
  `sPassword` varchar(35) NOT NULL,
  `bAdmin` tinyint(2) NOT NULL DEFAULT '0',
  `bMailIfOffline` tinyint(2) NOT NULL DEFAULT '0',
  `bActive` tinyint(2) NOT NULL DEFAULT '0',
  `sLanguage` varchar(5) NOT NULL,
  `bDashboardNavShown` tinyint(2) unsigned NOT NULL DEFAULT '1',
  `bFirstTime` tinyint(4) DEFAULT '0',
  PRIMARY KEY (`nId`),
  UNIQUE KEY `bDeleted_sMail` (`bDeleted`,`sMail`),
  UNIQUE KEY `sHashId` (`sHashId`)
) ENGINE=MyISAM AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.user: 5 rows
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `sMail`, `sName`, `sPassword`, `bAdmin`, `bMailIfOffline`, `bActive`, `sLanguage`, `bDashboardNavShown`, `bFirstTime`) VALUES
	(3, 'uYzc5N2UzNDZjMjk:', 0, 1445343102, 0, 0, 0, 'user2@test.de', 'User2@test.de', 'ec7cdd05b80f75a61ba1b099c9df083a', 0, 1, 1, 'de_DE', 1, 0),
	(4, 'uZDNlMTNiOGNjM2Y:', 0, 1445343055, 1446141818, 0, 6, 'user@test.de', 'äöü#^°123´`?4/*<html>', 'ec7cdd05b80f75a61ba1b099c9df083a', 0, 1, 1, 'de_DE', 1, 0),
	(5, 'uM2U0ODVlZWMwMTc:', 0, 1445343076, 1446219870, 0, 5, 'admin@test.de', 'Admin@test.de', 'ec7cdd05b80f75a61ba1b099c9df083a', 1, 1, 1, 'de_DE', 1, 0),
	(6, 'uYjhkOTdlMjUzMTU:', 0, 1445343123, 1446141790, 0, 6, 'admin2@test.de', 'Admin2@test.de', 'ec7cdd05b80f75a61ba1b099c9df083a', 1, 1, 1, 'de_DE', 1, 0),
	(8, 'uMTQ1Y2M5ZWE3ZWE:', 0, 1446138357, 0, 5, 0, 'institutionadmin@test.de', 'äöü#^°123´`?4/*<html>', 'ec7cdd05b80f75a61ba1b099c9df083a', 0, 1, 1, 'de_DE', 1, 0);
/*!40000 ALTER TABLE `user` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.user2group
CREATE TABLE IF NOT EXISTS `user2group` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `nStart` int(11) unsigned DEFAULT NULL,
  `nEnd` int(11) unsigned DEFAULT NULL,
  `nIdUser` int(11) unsigned NOT NULL,
  `nIdGroup` int(11) unsigned DEFAULT NULL,
  `nIdChapter` int(11) unsigned NOT NULL,
  `nIdModule` int(11) unsigned NOT NULL,
  `bAdmin` tinyint(2) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId` (`sHashId`),
  UNIQUE KEY `bDeleted_nIdUser_nIdGroup` (`bDeleted`,`nIdUser`,`nIdGroup`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- Exportiere Daten aus Tabelle iiigel.user2group: ~4 rows (ungefähr)
/*!40000 ALTER TABLE `user2group` DISABLE KEYS */;
INSERT INTO `user2group` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `nStart`, `nEnd`, `nIdUser`, `nIdGroup`, `nIdChapter`, `nIdModule`, `bAdmin`) VALUES
	(1, 'IsrzsgEMv7WAVVd:', 0, 0, 0, 0, 0, NULL, NULL, 5, 1, 1, 1, 0),
	(2, 'K3lvPWEX1Roa1ZV:', 0, 0, 0, 0, 0, NULL, NULL, 4, 1, 1, 2, 1),
	(3, 'WgDUzX7JT33YuDi:', 0, 0, 0, 0, 0, NULL, NULL, 6, 3, 1, 3, 1),
	(4, 'qpkcmQv8uqP0DPV:', 0, 0, 0, 0, 0, NULL, NULL, 3, 3, 2, 3, 0);
/*!40000 ALTER TABLE `user2group` ENABLE KEYS */;


-- Exportiere Struktur von Tabelle iiigel.user2institution
CREATE TABLE IF NOT EXISTS `user2institution` (
  `nId` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `sHashId` varchar(30) NOT NULL,
  `bDeleted` tinyint(2) unsigned NOT NULL DEFAULT '0',
  `nCreate` int(35) unsigned NOT NULL,
  `nUpdate` int(35) unsigned NOT NULL,
  `nIdCreator` int(11) unsigned NOT NULL,
  `nIdUpdater` int(11) unsigned NOT NULL,
  `nStart` int(11) unsigned DEFAULT NULL,
  `nEnd` int(11) unsigned DEFAULT NULL,
  `nIdUser` int(11) unsigned NOT NULL,
  `nIdInstitution` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`nId`),
  UNIQUE KEY `sHashId` (`sHashId`),
  UNIQUE KEY `bDeleted_nIdUser_nIdGroup` (`bDeleted`,`nIdUser`,`nIdInstitution`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;

-- Exportiere Daten aus Tabelle iiigel.user2institution: ~5 rows (ungefähr)
/*!40000 ALTER TABLE `user2institution` DISABLE KEYS */;
INSERT INTO `user2institution` (`nId`, `sHashId`, `bDeleted`, `nCreate`, `nUpdate`, `nIdCreator`, `nIdUpdater`, `nStart`, `nEnd`, `nIdUser`, `nIdInstitution`) VALUES
	(1, 'F9nb0I5DtsOd2Dd:', 0, 0, 0, 0, 0, NULL, NULL, 3, 1),
	(2, 'gKftFgrTeHLQ1n4:', 0, 0, 0, 0, 0, NULL, NULL, 4, 2),
	(3, '48AzgoYodTz5N2u:', 0, 0, 0, 0, 0, NULL, NULL, 4, 3),
	(4, 'rkM0iJlEmcNsDJU:', 0, 0, 0, 0, 0, NULL, NULL, 5, 3),
	(5, 'PxNyaqylCIUJl31:', 0, 0, 0, 0, 0, NULL, NULL, 6, 1);
/*!40000 ALTER TABLE `user2institution` ENABLE KEYS */;
/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
